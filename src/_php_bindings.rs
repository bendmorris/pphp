/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const ZEND_VERSION: &'static [u8; 6usize] = b"3.0.0\x00";
pub const ZEND_MAX_RESERVED_RESOURCES: ::std::os::raw::c_uint = 4;
pub const MEMORY_LIMIT: ::std::os::raw::c_uint = 0;
pub const COMPILE_DL_READLINE: ::std::os::raw::c_uint = 1;
pub const COOKIE_SEEKER_USES_OFF64_T: ::std::os::raw::c_uint = 1;
pub const DEFAULT_SHORT_OPEN_TAG: &'static [u8; 2usize] = b"1\x00";
pub const ENABLE_CHROOT_FUNC: ::std::os::raw::c_uint = 1;
pub const HAVE_ACOSH: ::std::os::raw::c_uint = 1;
pub const HAVE_ALIGNOF: ::std::os::raw::c_uint = 1;
pub const HAVE_ALLOCA: ::std::os::raw::c_uint = 1;
pub const HAVE_ALLOCA_H: ::std::os::raw::c_uint = 1;
pub const HAVE_ALPHASORT: ::std::os::raw::c_uint = 1;
pub const HAVE_ARPA_INET_H: ::std::os::raw::c_uint = 1;
pub const HAVE_ARPA_NAMESER_H: ::std::os::raw::c_uint = 1;
pub const HAVE_ASCTIME_R: ::std::os::raw::c_uint = 1;
pub const HAVE_ASINH: ::std::os::raw::c_uint = 1;
pub const HAVE_ASPRINTF: ::std::os::raw::c_uint = 1;
pub const HAVE_ASSERT_H: ::std::os::raw::c_uint = 1;
pub const HAVE_ATANH: ::std::os::raw::c_uint = 1;
pub const HAVE_ATOF_ACCEPTS_INF: ::std::os::raw::c_uint = 1;
pub const HAVE_ATOF_ACCEPTS_NAN: ::std::os::raw::c_uint = 1;
pub const HAVE_ATOLL: ::std::os::raw::c_uint = 1;
pub const HAVE_ATTRIBUTE_ALIGNED: ::std::os::raw::c_uint = 1;
pub const HAVE_BROKEN_GLIBC_FOPEN_APPEND: ::std::os::raw::c_uint = 1;
pub const HAVE_BUILD_DEFS_H: ::std::os::raw::c_uint = 1;
pub const HAVE_CHROOT: ::std::os::raw::c_uint = 1;
pub const HAVE_CRYPT: ::std::os::raw::c_uint = 1;
pub const HAVE_CRYPT_H: ::std::os::raw::c_uint = 1;
pub const HAVE_CTIME_R: ::std::os::raw::c_uint = 1;
pub const HAVE_CUSERID: ::std::os::raw::c_uint = 1;
pub const HAVE_DECLARED_TIMEZONE: ::std::os::raw::c_uint = 1;
pub const HAVE_DECL_ARC4RANDOM_BUF: ::std::os::raw::c_uint = 0;
pub const HAVE_DECL_ISFINITE: ::std::os::raw::c_uint = 1;
pub const HAVE_DECL_ISINF: ::std::os::raw::c_uint = 1;
pub const HAVE_DECL_ISNAN: ::std::os::raw::c_uint = 1;
pub const HAVE_DEV_URANDOM: ::std::os::raw::c_uint = 1;
pub const HAVE_DIRENT_H: ::std::os::raw::c_uint = 1;
pub const HAVE_DLFCN_H: ::std::os::raw::c_uint = 1;
pub const HAVE_DLOPEN: ::std::os::raw::c_uint = 1;
pub const HAVE_DN_EXPAND: ::std::os::raw::c_uint = 1;
pub const HAVE_DN_SKIPNAME: ::std::os::raw::c_uint = 1;
pub const HAVE_DTRACE: ::std::os::raw::c_uint = 1;
pub const HAVE_FCNTL_H: ::std::os::raw::c_uint = 1;
pub const HAVE_FINITE: ::std::os::raw::c_uint = 1;
pub const HAVE_FLOCK: ::std::os::raw::c_uint = 1;
pub const HAVE_FNMATCH: ::std::os::raw::c_uint = 1;
pub const HAVE_FOPENCOOKIE: ::std::os::raw::c_uint = 1;
pub const HAVE_FORK: ::std::os::raw::c_uint = 1;
pub const HAVE_FPU_INLINE_ASM_X86: ::std::os::raw::c_uint = 1;
pub const HAVE_FTOK: ::std::os::raw::c_uint = 1;
pub const HAVE_FUNC_GETHOSTBYNAME_R_6: ::std::os::raw::c_uint = 1;
pub const HAVE_GAI_STRERROR: ::std::os::raw::c_uint = 1;
pub const HAVE_GCC_GLOBAL_REGS: ::std::os::raw::c_uint = 1;
pub const HAVE_GCVT: ::std::os::raw::c_uint = 1;
pub const HAVE_GETADDRINFO: ::std::os::raw::c_uint = 1;
pub const HAVE_GETCWD: ::std::os::raw::c_uint = 1;
pub const HAVE_GETGRNAM_R: ::std::os::raw::c_uint = 1;
pub const HAVE_GETHOSTBYADDR: ::std::os::raw::c_uint = 1;
pub const HAVE_GETHOSTBYNAME_R: ::std::os::raw::c_uint = 1;
pub const HAVE_GETHOSTNAME: ::std::os::raw::c_uint = 1;
pub const HAVE_GETLOADAVG: ::std::os::raw::c_uint = 1;
pub const HAVE_GETLOGIN: ::std::os::raw::c_uint = 1;
pub const HAVE_GETOPT: ::std::os::raw::c_uint = 1;
pub const HAVE_GETPID: ::std::os::raw::c_uint = 1;
pub const HAVE_GETPRIORITY: ::std::os::raw::c_uint = 1;
pub const HAVE_GETPROTOBYNAME: ::std::os::raw::c_uint = 1;
pub const HAVE_GETPROTOBYNUMBER: ::std::os::raw::c_uint = 1;
pub const HAVE_GETPWNAM_R: ::std::os::raw::c_uint = 1;
pub const HAVE_GETPWUID_R: ::std::os::raw::c_uint = 1;
pub const HAVE_GETRUSAGE: ::std::os::raw::c_uint = 1;
pub const HAVE_GETSERVBYNAME: ::std::os::raw::c_uint = 1;
pub const HAVE_GETSERVBYPORT: ::std::os::raw::c_uint = 1;
pub const HAVE_GETTIMEOFDAY: ::std::os::raw::c_uint = 1;
pub const HAVE_GETWD: ::std::os::raw::c_uint = 1;
pub const HAVE_GLOB: ::std::os::raw::c_uint = 1;
pub const HAVE_GMTIME_R: ::std::os::raw::c_uint = 1;
pub const HAVE_GRANTPT: ::std::os::raw::c_uint = 1;
pub const HAVE_GRP_H: ::std::os::raw::c_uint = 1;
pub const HAVE_HASH_EXT: ::std::os::raw::c_uint = 1;
pub const HAVE_HTONL: ::std::os::raw::c_uint = 1;
pub const HAVE_HUGE_VAL_INF: ::std::os::raw::c_uint = 1;
pub const HAVE_HUGE_VAL_NAN: ::std::os::raw::c_uint = 1;
pub const HAVE_HYPOT: ::std::os::raw::c_uint = 1;
pub const HAVE_INET_ATON: ::std::os::raw::c_uint = 1;
pub const HAVE_INET_NTOA: ::std::os::raw::c_uint = 1;
pub const HAVE_INET_NTOP: ::std::os::raw::c_uint = 1;
pub const HAVE_INET_PTON: ::std::os::raw::c_uint = 1;
pub const HAVE_INT16_T: ::std::os::raw::c_uint = 1;
pub const HAVE_INT32_T: ::std::os::raw::c_uint = 1;
pub const HAVE_INT64_T: ::std::os::raw::c_uint = 1;
pub const HAVE_INT8_T: ::std::os::raw::c_uint = 1;
pub const HAVE_INTMAX_T: ::std::os::raw::c_uint = 1;
pub const HAVE_INTTYPES_H: ::std::os::raw::c_uint = 1;
pub const HAVE_IPV6: ::std::os::raw::c_uint = 1;
pub const HAVE_ISASCII: ::std::os::raw::c_uint = 1;
pub const HAVE_KILL: ::std::os::raw::c_uint = 1;
pub const HAVE_LANGINFO_H: ::std::os::raw::c_uint = 1;
pub const HAVE_LCHOWN: ::std::os::raw::c_uint = 1;
pub const HAVE_LIBDL: ::std::os::raw::c_uint = 1;
pub const HAVE_LIBEDIT: ::std::os::raw::c_uint = 1;
pub const HAVE_LIBM: ::std::os::raw::c_uint = 1;
pub const HAVE_LIBNSL: ::std::os::raw::c_uint = 1;
pub const HAVE_LIBRESOLV: ::std::os::raw::c_uint = 1;
pub const HAVE_LIBRT: ::std::os::raw::c_uint = 1;
pub const HAVE_LIBXML: ::std::os::raw::c_uint = 1;
pub const HAVE_LIMITS_H: ::std::os::raw::c_uint = 1;
pub const HAVE_LINK: ::std::os::raw::c_uint = 1;
pub const HAVE_LOCALECONV: ::std::os::raw::c_uint = 1;
pub const HAVE_LOCALE_H: ::std::os::raw::c_uint = 1;
pub const HAVE_LOCALTIME_R: ::std::os::raw::c_uint = 1;
pub const HAVE_LOCKF: ::std::os::raw::c_uint = 1;
pub const HAVE_LOG1P: ::std::os::raw::c_uint = 1;
pub const HAVE_LRAND48: ::std::os::raw::c_uint = 1;
pub const HAVE_MALLOC_H: ::std::os::raw::c_uint = 1;
pub const HAVE_MBLEN: ::std::os::raw::c_uint = 1;
pub const HAVE_MBRLEN: ::std::os::raw::c_uint = 1;
pub const HAVE_MBSINIT: ::std::os::raw::c_uint = 1;
pub const HAVE_MBSTATE_T: ::std::os::raw::c_uint = 1;
pub const HAVE_MEMCPY: ::std::os::raw::c_uint = 1;
pub const HAVE_MEMMOVE: ::std::os::raw::c_uint = 1;
pub const HAVE_MEMORY_H: ::std::os::raw::c_uint = 1;
pub const HAVE_MEMPCPY: ::std::os::raw::c_uint = 1;
pub const HAVE_MEM_MMAP_ANON: ::std::os::raw::c_uint = 1;
pub const HAVE_MEM_MMAP_ZERO: ::std::os::raw::c_uint = 1;
pub const HAVE_MKSTEMP: ::std::os::raw::c_uint = 1;
pub const HAVE_MMAP: ::std::os::raw::c_uint = 1;
pub const HAVE_MONETARY_H: ::std::os::raw::c_uint = 1;
pub const HAVE_MREMAP: ::std::os::raw::c_uint = 1;
pub const HAVE_NANOSLEEP: ::std::os::raw::c_uint = 1;
pub const HAVE_NETDB_H: ::std::os::raw::c_uint = 1;
pub const HAVE_NETINET_IN_H: ::std::os::raw::c_uint = 1;
pub const HAVE_NICE: ::std::os::raw::c_uint = 1;
pub const HAVE_NL_LANGINFO: ::std::os::raw::c_uint = 1;
pub const HAVE_OPENSSL_EXT: ::std::os::raw::c_uint = 1;
pub const HAVE_PCRE: ::std::os::raw::c_uint = 1;
pub const HAVE_PCRE_JIT_SUPPORT: ::std::os::raw::c_uint = 1;
pub const HAVE_PERROR: ::std::os::raw::c_uint = 1;
pub const HAVE_PHP_SESSION: ::std::os::raw::c_uint = 1;
pub const HAVE_POLL: ::std::os::raw::c_uint = 1;
pub const HAVE_POLL_H: ::std::os::raw::c_uint = 1;
pub const HAVE_POSIX_READDIR_R: ::std::os::raw::c_uint = 1;
pub const HAVE_PREAD: ::std::os::raw::c_uint = 1;
pub const HAVE_PTRDIFF_T: ::std::os::raw::c_uint = 1;
pub const HAVE_PTSNAME: ::std::os::raw::c_uint = 1;
pub const HAVE_PUTENV: ::std::os::raw::c_uint = 1;
pub const HAVE_PWD_H: ::std::os::raw::c_uint = 1;
pub const HAVE_PWRITE: ::std::os::raw::c_uint = 1;
pub const HAVE_RANDOM: ::std::os::raw::c_uint = 1;
pub const HAVE_RAND_R: ::std::os::raw::c_uint = 1;
pub const HAVE_REALPATH: ::std::os::raw::c_uint = 1;
pub const HAVE_REFLECTION: ::std::os::raw::c_uint = 1;
pub const HAVE_RESOLV_H: ::std::os::raw::c_uint = 1;
pub const HAVE_RES_NSEARCH: ::std::os::raw::c_uint = 1;
pub const HAVE_RES_SEARCH: ::std::os::raw::c_uint = 1;
pub const HAVE_RL_CALLBACK_READ_CHAR: ::std::os::raw::c_uint = 1;
pub const HAVE_RL_ON_NEW_LINE: ::std::os::raw::c_uint = 1;
pub const HAVE_SCANDIR: ::std::os::raw::c_uint = 1;
pub const HAVE_SETENV: ::std::os::raw::c_uint = 1;
pub const HAVE_SETITIMER: ::std::os::raw::c_uint = 1;
pub const HAVE_SETLOCALE: ::std::os::raw::c_uint = 1;
pub const HAVE_SETPGID: ::std::os::raw::c_uint = 1;
pub const HAVE_SETPRIORITY: ::std::os::raw::c_uint = 1;
pub const HAVE_SETSOCKOPT: ::std::os::raw::c_uint = 1;
pub const HAVE_SETVBUF: ::std::os::raw::c_uint = 1;
pub const HAVE_SHUTDOWN: ::std::os::raw::c_uint = 1;
pub const HAVE_SIGACTION: ::std::os::raw::c_uint = 1;
pub const HAVE_SIGNAL_H: ::std::os::raw::c_uint = 1;
pub const HAVE_SIGPROCMASK: ::std::os::raw::c_uint = 1;
pub const HAVE_SIGTIMEDWAIT: ::std::os::raw::c_uint = 1;
pub const HAVE_SIGWAITINFO: ::std::os::raw::c_uint = 1;
pub const HAVE_SIN: ::std::os::raw::c_uint = 1;
pub const HAVE_SNPRINTF: ::std::os::raw::c_uint = 1;
pub const HAVE_SOCKADDR_STORAGE: ::std::os::raw::c_uint = 1;
pub const HAVE_SOCKET: ::std::os::raw::c_uint = 1;
pub const HAVE_SOCKETPAIR: ::std::os::raw::c_uint = 1;
pub const HAVE_SOCKLEN_T: ::std::os::raw::c_uint = 1;
pub const HAVE_SPL: ::std::os::raw::c_uint = 1;
pub const HAVE_SRAND48: ::std::os::raw::c_uint = 1;
pub const HAVE_SRANDOM: ::std::os::raw::c_uint = 1;
pub const HAVE_SSIZE_T: ::std::os::raw::c_uint = 1;
pub const HAVE_STATFS: ::std::os::raw::c_uint = 1;
pub const HAVE_STATVFS: ::std::os::raw::c_uint = 1;
pub const HAVE_STDARG_H: ::std::os::raw::c_uint = 1;
pub const HAVE_STDINT_H: ::std::os::raw::c_uint = 1;
pub const HAVE_STDLIB_H: ::std::os::raw::c_uint = 1;
pub const HAVE_STRCASECMP: ::std::os::raw::c_uint = 1;
pub const HAVE_STRCOLL: ::std::os::raw::c_uint = 1;
pub const HAVE_STRDUP: ::std::os::raw::c_uint = 1;
pub const HAVE_STRERROR: ::std::os::raw::c_uint = 1;
pub const HAVE_STRFMON: ::std::os::raw::c_uint = 1;
pub const HAVE_STRFTIME: ::std::os::raw::c_uint = 1;
pub const HAVE_STRINGS_H: ::std::os::raw::c_uint = 1;
pub const HAVE_STRING_H: ::std::os::raw::c_uint = 1;
pub const HAVE_STRNLEN: ::std::os::raw::c_uint = 1;
pub const HAVE_STRPTIME: ::std::os::raw::c_uint = 1;
pub const HAVE_STRPTIME_DECL_FAILS: ::std::os::raw::c_uint = 1;
pub const HAVE_STRSTR: ::std::os::raw::c_uint = 1;
pub const HAVE_STRTOD: ::std::os::raw::c_uint = 1;
pub const HAVE_STRTOK_R: ::std::os::raw::c_uint = 1;
pub const HAVE_STRTOL: ::std::os::raw::c_uint = 1;
pub const HAVE_STRTOLL: ::std::os::raw::c_uint = 1;
pub const HAVE_STRUCT_FLOCK: ::std::os::raw::c_uint = 1;
pub const HAVE_STRUCT_STAT_ST_BLKSIZE: ::std::os::raw::c_uint = 1;
pub const HAVE_STRUCT_STAT_ST_BLOCKS: ::std::os::raw::c_uint = 1;
pub const HAVE_STRUCT_STAT_ST_RDEV: ::std::os::raw::c_uint = 1;
pub const HAVE_STRUCT_TM_TM_ZONE: ::std::os::raw::c_uint = 1;
pub const HAVE_ST_BLKSIZE: ::std::os::raw::c_uint = 1;
pub const HAVE_ST_BLOCKS: ::std::os::raw::c_uint = 1;
pub const HAVE_ST_RDEV: ::std::os::raw::c_uint = 1;
pub const HAVE_SYMLINK: ::std::os::raw::c_uint = 1;
pub const HAVE_SYNC_FETCH_AND_ADD: ::std::os::raw::c_uint = 1;
pub const HAVE_SYSEXITS_H: ::std::os::raw::c_uint = 1;
pub const HAVE_SYSLOG_H: ::std::os::raw::c_uint = 1;
pub const HAVE_SYSTEM_TZDATA: ::std::os::raw::c_uint = 1;
pub const HAVE_SYS_FILE_H: ::std::os::raw::c_uint = 1;
pub const HAVE_SYS_IOCTL_H: ::std::os::raw::c_uint = 1;
pub const HAVE_SYS_IPC_H: ::std::os::raw::c_uint = 1;
pub const HAVE_SYS_MMAN_H: ::std::os::raw::c_uint = 1;
pub const HAVE_SYS_MOUNT_H: ::std::os::raw::c_uint = 1;
pub const HAVE_SYS_PARAM_H: ::std::os::raw::c_uint = 1;
pub const HAVE_SYS_POLL_H: ::std::os::raw::c_uint = 1;
pub const HAVE_SYS_RESOURCE_H: ::std::os::raw::c_uint = 1;
pub const HAVE_SYS_SDT_H: ::std::os::raw::c_uint = 1;
pub const HAVE_SYS_SELECT_H: ::std::os::raw::c_uint = 1;
pub const HAVE_SYS_SOCKET_H: ::std::os::raw::c_uint = 1;
pub const HAVE_SYS_STATFS_H: ::std::os::raw::c_uint = 1;
pub const HAVE_SYS_STATVFS_H: ::std::os::raw::c_uint = 1;
pub const HAVE_SYS_STAT_H: ::std::os::raw::c_uint = 1;
pub const HAVE_SYS_TIME_H: ::std::os::raw::c_uint = 1;
pub const HAVE_SYS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const HAVE_SYS_UTSNAME_H: ::std::os::raw::c_uint = 1;
pub const HAVE_SYS_VFS_H: ::std::os::raw::c_uint = 1;
pub const HAVE_SYS_WAIT_H: ::std::os::raw::c_uint = 1;
pub const HAVE_TEMPNAM: ::std::os::raw::c_uint = 1;
pub const HAVE_TERMIOS_H: ::std::os::raw::c_uint = 1;
pub const HAVE_TIMELIB_CONFIG_H: ::std::os::raw::c_uint = 1;
pub const HAVE_TM_GMTOFF: ::std::os::raw::c_uint = 1;
pub const HAVE_TM_ZONE: ::std::os::raw::c_uint = 1;
pub const HAVE_TZSET: ::std::os::raw::c_uint = 1;
pub const HAVE_UINT16_T: ::std::os::raw::c_uint = 1;
pub const HAVE_UINT32_T: ::std::os::raw::c_uint = 1;
pub const HAVE_UINT64_T: ::std::os::raw::c_uint = 1;
pub const HAVE_UINT8_T: ::std::os::raw::c_uint = 1;
pub const HAVE_UNISTD_H: ::std::os::raw::c_uint = 1;
pub const HAVE_UNLOCKPT: ::std::os::raw::c_uint = 1;
pub const HAVE_UNSETENV: ::std::os::raw::c_uint = 1;
pub const HAVE_USLEEP: ::std::os::raw::c_uint = 1;
pub const HAVE_UTIME: ::std::os::raw::c_uint = 1;
pub const HAVE_UTIME_H: ::std::os::raw::c_uint = 1;
pub const HAVE_UTIME_NULL: ::std::os::raw::c_uint = 1;
pub const HAVE_U_INT16_T: ::std::os::raw::c_uint = 1;
pub const HAVE_U_INT32_T: ::std::os::raw::c_uint = 1;
pub const HAVE_U_INT64_T: ::std::os::raw::c_uint = 1;
pub const HAVE_U_INT8_T: ::std::os::raw::c_uint = 1;
pub const HAVE_VASPRINTF: ::std::os::raw::c_uint = 1;
pub const HAVE_VPRINTF: ::std::os::raw::c_uint = 1;
pub const HAVE_VSNPRINTF: ::std::os::raw::c_uint = 1;
pub const HAVE_WAIT3: ::std::os::raw::c_uint = 1;
pub const HAVE_WAIT4: ::std::os::raw::c_uint = 1;
pub const HAVE_WAITPID: ::std::os::raw::c_uint = 1;
pub const HAVE_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const HAVE_YP_GET_DEFAULT_DOMAIN: ::std::os::raw::c_uint = 1;
pub const HAVE_ZLIB: ::std::os::raw::c_uint = 1;
pub const HAVE__FPU_SETCW: ::std::os::raw::c_uint = 1;
pub const LT_OBJDIR: &'static [u8; 7usize] = b".libs/\x00";
pub const MISSING_FCLOSE_DECL: ::std::os::raw::c_uint = 0;
pub const ODBCVER: ::std::os::raw::c_uint = 768;
pub const PACKAGE_BUGREPORT: &'static [u8; 1usize] = b"\x00";
pub const PACKAGE_NAME: &'static [u8; 1usize] = b"\x00";
pub const PACKAGE_STRING: &'static [u8; 1usize] = b"\x00";
pub const PACKAGE_TARNAME: &'static [u8; 1usize] = b"\x00";
pub const PACKAGE_URL: &'static [u8; 1usize] = b"\x00";
pub const PACKAGE_VERSION: &'static [u8; 1usize] = b"\x00";
pub const PHP_BLOWFISH_CRYPT: ::std::os::raw::c_uint = 1;
pub const PHP_BUILD_DATE: &'static [u8; 11usize] = b"2017-08-01\x00";
pub const PHP_CAN_SUPPORT_PROC_OPEN: ::std::os::raw::c_uint = 1;
pub const PHP_EXT_DES_CRYPT: ::std::os::raw::c_uint = 1;
pub const PHP_HAVE_BUILTIN_CLZ: ::std::os::raw::c_uint = 1;
pub const PHP_HAVE_BUILTIN_CTZL: ::std::os::raw::c_uint = 1;
pub const PHP_HAVE_BUILTIN_CTZLL: ::std::os::raw::c_uint = 1;
pub const PHP_HAVE_BUILTIN_EXPECT: ::std::os::raw::c_uint = 1;
pub const PHP_HAVE_STDINT_TYPES: ::std::os::raw::c_uint = 1;
pub const PHP_MD5_CRYPT: ::std::os::raw::c_uint = 1;
pub const PHP_MHASH_BC: ::std::os::raw::c_uint = 1;
pub const PHP_OS: &'static [u8; 6usize] = b"Linux\x00";
pub const PHP_SHA256_CRYPT: ::std::os::raw::c_uint = 1;
pub const PHP_SHA512_CRYPT: ::std::os::raw::c_uint = 1;
pub const PHP_SIGCHILD: ::std::os::raw::c_uint = 0;
pub const PHP_STD_DES_CRYPT: ::std::os::raw::c_uint = 1;
pub const PHP_UNAME: &'static [u8; 6usize] = b"Linux\x00";
pub const PHP_USE_PHP_CRYPT_R: ::std::os::raw::c_uint = 1;
pub const PHP_WRITE_STDOUT: ::std::os::raw::c_uint = 1;
pub const SIZEOF_INT: ::std::os::raw::c_uint = 4;
pub const SIZEOF_INTMAX_T: ::std::os::raw::c_uint = 8;
pub const SIZEOF_LONG: ::std::os::raw::c_uint = 8;
pub const SIZEOF_LONG_LONG: ::std::os::raw::c_uint = 8;
pub const SIZEOF_LONG_LONG_INT: ::std::os::raw::c_uint = 8;
pub const SIZEOF_PTRDIFF_T: ::std::os::raw::c_uint = 8;
pub const SIZEOF_SHORT: ::std::os::raw::c_uint = 2;
pub const SIZEOF_SIZE_T: ::std::os::raw::c_uint = 8;
pub const SIZEOF_SSIZE_T: ::std::os::raw::c_uint = 8;
pub const STDC_HEADERS: ::std::os::raw::c_uint = 1;
pub const _ALL_SOURCE: ::std::os::raw::c_uint = 1;
pub const _GNU_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_PTHREAD_SEMANTICS: ::std::os::raw::c_uint = 1;
pub const _TANDEM_SOURCE: ::std::os::raw::c_uint = 1;
pub const __EXTENSIONS__: ::std::os::raw::c_uint = 1;
pub const ZEND_BROKEN_SPRINTF: ::std::os::raw::c_uint = 0;
pub const ZEND_DEBUG: ::std::os::raw::c_uint = 0;
pub const ZEND_MM_ALIGNMENT: ::std::os::raw::c_uint = 8;
pub const ZEND_MM_ALIGNMENT_LOG2: ::std::os::raw::c_uint = 3;
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _ISOC95_SOURCE: ::std::os::raw::c_uint = 1;
pub const _ISOC99_SOURCE: ::std::os::raw::c_uint = 1;
pub const _ISOC11_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const _XOPEN_SOURCE: ::std::os::raw::c_uint = 700;
pub const _XOPEN_SOURCE_EXTENDED: ::std::os::raw::c_uint = 1;
pub const _LARGEFILE64_SOURCE: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN_EXTENDED: ::std::os::raw::c_uint = 1;
pub const __USE_UNIX98: ::std::os::raw::c_uint = 1;
pub const _LARGEFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8XSI: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2KXSI: ::std::os::raw::c_uint = 1;
pub const __USE_LARGEFILE: ::std::os::raw::c_uint = 1;
pub const __USE_LARGEFILE64: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_GNU: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201505;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 23;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const _STDLIB_H: ::std::os::raw::c_uint = 1;
pub const WNOHANG: ::std::os::raw::c_uint = 1;
pub const WUNTRACED: ::std::os::raw::c_uint = 2;
pub const WSTOPPED: ::std::os::raw::c_uint = 2;
pub const WEXITED: ::std::os::raw::c_uint = 4;
pub const WCONTINUED: ::std::os::raw::c_uint = 8;
pub const WNOWAIT: ::std::os::raw::c_uint = 16777216;
pub const __WNOTHREAD: ::std::os::raw::c_uint = 536870912;
pub const __WALL: ::std::os::raw::c_uint = 1073741824;
pub const __WCLONE: ::std::os::raw::c_uint = 2147483648;
pub const __ENUM_IDTYPE_T: ::std::os::raw::c_uint = 1;
pub const __W_CONTINUED: ::std::os::raw::c_uint = 65535;
pub const __WCOREFLAG: ::std::os::raw::c_uint = 128;
pub const _ENDIAN_H: ::std::os::raw::c_uint = 1;
pub const __LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const __BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const __PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const __BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const __FLOAT_WORD_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const _BITS_BYTESWAP_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPESIZES_H: ::std::os::raw::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::std::os::raw::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::std::os::raw::c_uint = 1;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const __ldiv_t_defined: ::std::os::raw::c_uint = 1;
pub const __lldiv_t_defined: ::std::os::raw::c_uint = 1;
pub const RAND_MAX: ::std::os::raw::c_uint = 2147483647;
pub const EXIT_FAILURE: ::std::os::raw::c_uint = 1;
pub const EXIT_SUCCESS: ::std::os::raw::c_uint = 0;
pub const _XLOCALE_H: ::std::os::raw::c_uint = 1;
pub const _SYS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const __clock_t_defined: ::std::os::raw::c_uint = 1;
pub const __time_t_defined: ::std::os::raw::c_uint = 1;
pub const __clockid_t_defined: ::std::os::raw::c_uint = 1;
pub const __timer_t_defined: ::std::os::raw::c_uint = 1;
pub const __BIT_TYPES_DEFINED__: ::std::os::raw::c_uint = 1;
pub const _SYS_SELECT_H: ::std::os::raw::c_uint = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\x00";
pub const _SIGSET_H_types: ::std::os::raw::c_uint = 1;
pub const __timespec_defined: ::std::os::raw::c_uint = 1;
pub const _STRUCT_TIMEVAL: ::std::os::raw::c_uint = 1;
pub const FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _SYS_SYSMACROS_H: ::std::os::raw::c_uint = 1;
pub const _BITS_PTHREADTYPES_H: ::std::os::raw::c_uint = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_MUTEX_T: ::std::os::raw::c_uint = 40;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_COND_T: ::std::os::raw::c_uint = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_RWLOCK_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_PTHREAD_BARRIER_T: ::std::os::raw::c_uint = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: ::std::os::raw::c_uint = 4;
pub const __have_pthread_attr_t: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: ::std::os::raw::c_uint = 1;
pub const _ALLOCA_H: ::std::os::raw::c_uint = 1;
pub const _STRING_H: ::std::os::raw::c_uint = 1;
pub const _MATH_H: ::std::os::raw::c_uint = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: ::std::os::raw::c_uint = 1;
pub const _MATH_H_MATHDEF: ::std::os::raw::c_uint = 1;
pub const FP_ILOGB0: ::std::os::raw::c_int = -2147483648;
pub const FP_ILOGBNAN: ::std::os::raw::c_int = -2147483648;
pub const __MATH_DECLARING_DOUBLE: ::std::os::raw::c_uint = 1;
pub const __MATH_DECLARE_LDOUBLE: ::std::os::raw::c_uint = 1;
pub const MATH_ERRNO: ::std::os::raw::c_uint = 1;
pub const MATH_ERREXCEPT: ::std::os::raw::c_uint = 2;
pub const math_errhandling: ::std::os::raw::c_uint = 3;
pub const DOMAIN: ::std::os::raw::c_uint = 1;
pub const SING: ::std::os::raw::c_uint = 2;
pub const OVERFLOW: ::std::os::raw::c_uint = 3;
pub const UNDERFLOW: ::std::os::raw::c_uint = 4;
pub const TLOSS: ::std::os::raw::c_uint = 5;
pub const PLOSS: ::std::os::raw::c_uint = 6;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const M_El: f64 = 2.718281828459045;
pub const M_LOG2El: f64 = 1.4426950408889634;
pub const M_LOG10El: f64 = 0.4342944819032518;
pub const M_LN2l: f64 = 0.6931471805599453;
pub const M_LN10l: f64 = 2.302585092994046;
pub const M_PIl: f64 = 3.141592653589793;
pub const M_PI_2l: f64 = 1.5707963267948966;
pub const M_PI_4l: f64 = 0.7853981633974483;
pub const M_1_PIl: f64 = 0.3183098861837907;
pub const M_2_PIl: f64 = 0.6366197723675814;
pub const M_2_SQRTPIl: f64 = 1.1283791670955126;
pub const M_SQRT2l: f64 = 1.4142135623730951;
pub const M_SQRT1_2l: f64 = 0.7071067811865476;
pub const ZEND_PATHS_SEPARATOR: u8 = b':';
pub const _INTTYPES_H: ::std::os::raw::c_uint = 1;
pub const _STDINT_H: ::std::os::raw::c_uint = 1;
pub const _BITS_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_int = -1;
pub const UINT_FAST32_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_uint = 0;
pub const WINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const ____gwchar_t_defined: ::std::os::raw::c_uint = 1;
pub const __PRI64_PREFIX: &'static [u8; 2usize] = b"l\x00";
pub const __PRIPTR_PREFIX: &'static [u8; 2usize] = b"l\x00";
pub const PRId8: &'static [u8; 2usize] = b"d\x00";
pub const PRId16: &'static [u8; 2usize] = b"d\x00";
pub const PRId32: &'static [u8; 2usize] = b"d\x00";
pub const PRId64: &'static [u8; 3usize] = b"ld\x00";
pub const PRIdLEAST8: &'static [u8; 2usize] = b"d\x00";
pub const PRIdLEAST16: &'static [u8; 2usize] = b"d\x00";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\x00";
pub const PRIdLEAST64: &'static [u8; 3usize] = b"ld\x00";
pub const PRIdFAST8: &'static [u8; 2usize] = b"d\x00";
pub const PRIdFAST16: &'static [u8; 3usize] = b"ld\x00";
pub const PRIdFAST32: &'static [u8; 3usize] = b"ld\x00";
pub const PRIdFAST64: &'static [u8; 3usize] = b"ld\x00";
pub const PRIi8: &'static [u8; 2usize] = b"i\x00";
pub const PRIi16: &'static [u8; 2usize] = b"i\x00";
pub const PRIi32: &'static [u8; 2usize] = b"i\x00";
pub const PRIi64: &'static [u8; 3usize] = b"li\x00";
pub const PRIiLEAST8: &'static [u8; 2usize] = b"i\x00";
pub const PRIiLEAST16: &'static [u8; 2usize] = b"i\x00";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\x00";
pub const PRIiLEAST64: &'static [u8; 3usize] = b"li\x00";
pub const PRIiFAST8: &'static [u8; 2usize] = b"i\x00";
pub const PRIiFAST16: &'static [u8; 3usize] = b"li\x00";
pub const PRIiFAST32: &'static [u8; 3usize] = b"li\x00";
pub const PRIiFAST64: &'static [u8; 3usize] = b"li\x00";
pub const PRIo8: &'static [u8; 2usize] = b"o\x00";
pub const PRIo16: &'static [u8; 2usize] = b"o\x00";
pub const PRIo32: &'static [u8; 2usize] = b"o\x00";
pub const PRIo64: &'static [u8; 3usize] = b"lo\x00";
pub const PRIoLEAST8: &'static [u8; 2usize] = b"o\x00";
pub const PRIoLEAST16: &'static [u8; 2usize] = b"o\x00";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\x00";
pub const PRIoLEAST64: &'static [u8; 3usize] = b"lo\x00";
pub const PRIoFAST8: &'static [u8; 2usize] = b"o\x00";
pub const PRIoFAST16: &'static [u8; 3usize] = b"lo\x00";
pub const PRIoFAST32: &'static [u8; 3usize] = b"lo\x00";
pub const PRIoFAST64: &'static [u8; 3usize] = b"lo\x00";
pub const PRIu8: &'static [u8; 2usize] = b"u\x00";
pub const PRIu16: &'static [u8; 2usize] = b"u\x00";
pub const PRIu32: &'static [u8; 2usize] = b"u\x00";
pub const PRIu64: &'static [u8; 3usize] = b"lu\x00";
pub const PRIuLEAST8: &'static [u8; 2usize] = b"u\x00";
pub const PRIuLEAST16: &'static [u8; 2usize] = b"u\x00";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\x00";
pub const PRIuLEAST64: &'static [u8; 3usize] = b"lu\x00";
pub const PRIuFAST8: &'static [u8; 2usize] = b"u\x00";
pub const PRIuFAST16: &'static [u8; 3usize] = b"lu\x00";
pub const PRIuFAST32: &'static [u8; 3usize] = b"lu\x00";
pub const PRIuFAST64: &'static [u8; 3usize] = b"lu\x00";
pub const PRIx8: &'static [u8; 2usize] = b"x\x00";
pub const PRIx16: &'static [u8; 2usize] = b"x\x00";
pub const PRIx32: &'static [u8; 2usize] = b"x\x00";
pub const PRIx64: &'static [u8; 3usize] = b"lx\x00";
pub const PRIxLEAST8: &'static [u8; 2usize] = b"x\x00";
pub const PRIxLEAST16: &'static [u8; 2usize] = b"x\x00";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\x00";
pub const PRIxLEAST64: &'static [u8; 3usize] = b"lx\x00";
pub const PRIxFAST8: &'static [u8; 2usize] = b"x\x00";
pub const PRIxFAST16: &'static [u8; 3usize] = b"lx\x00";
pub const PRIxFAST32: &'static [u8; 3usize] = b"lx\x00";
pub const PRIxFAST64: &'static [u8; 3usize] = b"lx\x00";
pub const PRIX8: &'static [u8; 2usize] = b"X\x00";
pub const PRIX16: &'static [u8; 2usize] = b"X\x00";
pub const PRIX32: &'static [u8; 2usize] = b"X\x00";
pub const PRIX64: &'static [u8; 3usize] = b"lX\x00";
pub const PRIXLEAST8: &'static [u8; 2usize] = b"X\x00";
pub const PRIXLEAST16: &'static [u8; 2usize] = b"X\x00";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\x00";
pub const PRIXLEAST64: &'static [u8; 3usize] = b"lX\x00";
pub const PRIXFAST8: &'static [u8; 2usize] = b"X\x00";
pub const PRIXFAST16: &'static [u8; 3usize] = b"lX\x00";
pub const PRIXFAST32: &'static [u8; 3usize] = b"lX\x00";
pub const PRIXFAST64: &'static [u8; 3usize] = b"lX\x00";
pub const PRIdMAX: &'static [u8; 3usize] = b"ld\x00";
pub const PRIiMAX: &'static [u8; 3usize] = b"li\x00";
pub const PRIoMAX: &'static [u8; 3usize] = b"lo\x00";
pub const PRIuMAX: &'static [u8; 3usize] = b"lu\x00";
pub const PRIxMAX: &'static [u8; 3usize] = b"lx\x00";
pub const PRIXMAX: &'static [u8; 3usize] = b"lX\x00";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\x00";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\x00";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\x00";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\x00";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\x00";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\x00";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNd16: &'static [u8; 3usize] = b"hd\x00";
pub const SCNd32: &'static [u8; 2usize] = b"d\x00";
pub const SCNd64: &'static [u8; 3usize] = b"ld\x00";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\x00";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\x00";
pub const SCNdLEAST64: &'static [u8; 3usize] = b"ld\x00";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\x00";
pub const SCNdFAST16: &'static [u8; 3usize] = b"ld\x00";
pub const SCNdFAST32: &'static [u8; 3usize] = b"ld\x00";
pub const SCNdFAST64: &'static [u8; 3usize] = b"ld\x00";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNi16: &'static [u8; 3usize] = b"hi\x00";
pub const SCNi32: &'static [u8; 2usize] = b"i\x00";
pub const SCNi64: &'static [u8; 3usize] = b"li\x00";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\x00";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\x00";
pub const SCNiLEAST64: &'static [u8; 3usize] = b"li\x00";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\x00";
pub const SCNiFAST16: &'static [u8; 3usize] = b"li\x00";
pub const SCNiFAST32: &'static [u8; 3usize] = b"li\x00";
pub const SCNiFAST64: &'static [u8; 3usize] = b"li\x00";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNu16: &'static [u8; 3usize] = b"hu\x00";
pub const SCNu32: &'static [u8; 2usize] = b"u\x00";
pub const SCNu64: &'static [u8; 3usize] = b"lu\x00";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\x00";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\x00";
pub const SCNuLEAST64: &'static [u8; 3usize] = b"lu\x00";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\x00";
pub const SCNuFAST16: &'static [u8; 3usize] = b"lu\x00";
pub const SCNuFAST32: &'static [u8; 3usize] = b"lu\x00";
pub const SCNuFAST64: &'static [u8; 3usize] = b"lu\x00";
pub const SCNo8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNo16: &'static [u8; 3usize] = b"ho\x00";
pub const SCNo32: &'static [u8; 2usize] = b"o\x00";
pub const SCNo64: &'static [u8; 3usize] = b"lo\x00";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\x00";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\x00";
pub const SCNoLEAST64: &'static [u8; 3usize] = b"lo\x00";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\x00";
pub const SCNoFAST16: &'static [u8; 3usize] = b"lo\x00";
pub const SCNoFAST32: &'static [u8; 3usize] = b"lo\x00";
pub const SCNoFAST64: &'static [u8; 3usize] = b"lo\x00";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNx16: &'static [u8; 3usize] = b"hx\x00";
pub const SCNx32: &'static [u8; 2usize] = b"x\x00";
pub const SCNx64: &'static [u8; 3usize] = b"lx\x00";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\x00";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\x00";
pub const SCNxLEAST64: &'static [u8; 3usize] = b"lx\x00";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\x00";
pub const SCNxFAST16: &'static [u8; 3usize] = b"lx\x00";
pub const SCNxFAST32: &'static [u8; 3usize] = b"lx\x00";
pub const SCNxFAST64: &'static [u8; 3usize] = b"lx\x00";
pub const SCNdMAX: &'static [u8; 3usize] = b"ld\x00";
pub const SCNiMAX: &'static [u8; 3usize] = b"li\x00";
pub const SCNoMAX: &'static [u8; 3usize] = b"lo\x00";
pub const SCNuMAX: &'static [u8; 3usize] = b"lu\x00";
pub const SCNxMAX: &'static [u8; 3usize] = b"lx\x00";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\x00";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\x00";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\x00";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\x00";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\x00";
pub const _STDIO_H: ::std::os::raw::c_uint = 1;
pub const __FILE_defined: ::std::os::raw::c_uint = 1;
pub const ____FILE_defined: ::std::os::raw::c_uint = 1;
pub const _G_config_h: ::std::os::raw::c_uint = 1;
pub const ____mbstate_t_defined: ::std::os::raw::c_uint = 1;
pub const _G_HAVE_MMAP: ::std::os::raw::c_uint = 1;
pub const _G_HAVE_MREMAP: ::std::os::raw::c_uint = 1;
pub const _G_IO_IO_FILE_VERSION: ::std::os::raw::c_uint = 131073;
pub const _G_BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const _IO_BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const __GNUC_VA_LIST: ::std::os::raw::c_uint = 1;
pub const _IO_UNIFIED_JUMPTABLES: ::std::os::raw::c_uint = 1;
pub const EOF: ::std::os::raw::c_int = -1;
pub const _IOS_INPUT: ::std::os::raw::c_uint = 1;
pub const _IOS_OUTPUT: ::std::os::raw::c_uint = 2;
pub const _IOS_ATEND: ::std::os::raw::c_uint = 4;
pub const _IOS_APPEND: ::std::os::raw::c_uint = 8;
pub const _IOS_TRUNC: ::std::os::raw::c_uint = 16;
pub const _IOS_NOCREATE: ::std::os::raw::c_uint = 32;
pub const _IOS_NOREPLACE: ::std::os::raw::c_uint = 64;
pub const _IOS_BIN: ::std::os::raw::c_uint = 128;
pub const _IO_MAGIC: ::std::os::raw::c_uint = 4222418944;
pub const _OLD_STDIO_MAGIC: ::std::os::raw::c_uint = 4206624768;
pub const _IO_MAGIC_MASK: ::std::os::raw::c_uint = 4294901760;
pub const _IO_USER_BUF: ::std::os::raw::c_uint = 1;
pub const _IO_UNBUFFERED: ::std::os::raw::c_uint = 2;
pub const _IO_NO_READS: ::std::os::raw::c_uint = 4;
pub const _IO_NO_WRITES: ::std::os::raw::c_uint = 8;
pub const _IO_EOF_SEEN: ::std::os::raw::c_uint = 16;
pub const _IO_ERR_SEEN: ::std::os::raw::c_uint = 32;
pub const _IO_DELETE_DONT_CLOSE: ::std::os::raw::c_uint = 64;
pub const _IO_LINKED: ::std::os::raw::c_uint = 128;
pub const _IO_IN_BACKUP: ::std::os::raw::c_uint = 256;
pub const _IO_LINE_BUF: ::std::os::raw::c_uint = 512;
pub const _IO_TIED_PUT_GET: ::std::os::raw::c_uint = 1024;
pub const _IO_CURRENTLY_PUTTING: ::std::os::raw::c_uint = 2048;
pub const _IO_IS_APPENDING: ::std::os::raw::c_uint = 4096;
pub const _IO_IS_FILEBUF: ::std::os::raw::c_uint = 8192;
pub const _IO_BAD_SEEN: ::std::os::raw::c_uint = 16384;
pub const _IO_USER_LOCK: ::std::os::raw::c_uint = 32768;
pub const _IO_FLAGS2_MMAP: ::std::os::raw::c_uint = 1;
pub const _IO_FLAGS2_NOTCANCEL: ::std::os::raw::c_uint = 2;
pub const _IO_FLAGS2_USER_WBUF: ::std::os::raw::c_uint = 8;
pub const _IO_SKIPWS: ::std::os::raw::c_uint = 1;
pub const _IO_LEFT: ::std::os::raw::c_uint = 2;
pub const _IO_RIGHT: ::std::os::raw::c_uint = 4;
pub const _IO_INTERNAL: ::std::os::raw::c_uint = 8;
pub const _IO_DEC: ::std::os::raw::c_uint = 16;
pub const _IO_OCT: ::std::os::raw::c_uint = 32;
pub const _IO_HEX: ::std::os::raw::c_uint = 64;
pub const _IO_SHOWBASE: ::std::os::raw::c_uint = 128;
pub const _IO_SHOWPOINT: ::std::os::raw::c_uint = 256;
pub const _IO_UPPERCASE: ::std::os::raw::c_uint = 512;
pub const _IO_SHOWPOS: ::std::os::raw::c_uint = 1024;
pub const _IO_SCIENTIFIC: ::std::os::raw::c_uint = 2048;
pub const _IO_FIXED: ::std::os::raw::c_uint = 4096;
pub const _IO_UNITBUF: ::std::os::raw::c_uint = 8192;
pub const _IO_STDIO: ::std::os::raw::c_uint = 16384;
pub const _IO_DONT_CLOSE: ::std::os::raw::c_uint = 32768;
pub const _IO_BOOLALPHA: ::std::os::raw::c_uint = 65536;
pub const _IOFBF: ::std::os::raw::c_uint = 0;
pub const _IOLBF: ::std::os::raw::c_uint = 1;
pub const _IONBF: ::std::os::raw::c_uint = 2;
pub const BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const SEEK_SET: ::std::os::raw::c_uint = 0;
pub const SEEK_CUR: ::std::os::raw::c_uint = 1;
pub const SEEK_END: ::std::os::raw::c_uint = 2;
pub const SEEK_DATA: ::std::os::raw::c_uint = 3;
pub const SEEK_HOLE: ::std::os::raw::c_uint = 4;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\x00";
pub const L_tmpnam: ::std::os::raw::c_uint = 20;
pub const TMP_MAX: ::std::os::raw::c_uint = 238328;
pub const FILENAME_MAX: ::std::os::raw::c_uint = 4096;
pub const L_ctermid: ::std::os::raw::c_uint = 9;
pub const L_cuserid: ::std::os::raw::c_uint = 9;
pub const FOPEN_MAX: ::std::os::raw::c_uint = 16;
pub const _ASSERT_H: ::std::os::raw::c_uint = 1;
pub const _DLFCN_H: ::std::os::raw::c_uint = 1;
pub const RTLD_LAZY: ::std::os::raw::c_uint = 1;
pub const RTLD_NOW: ::std::os::raw::c_uint = 2;
pub const RTLD_BINDING_MASK: ::std::os::raw::c_uint = 3;
pub const RTLD_NOLOAD: ::std::os::raw::c_uint = 4;
pub const RTLD_DEEPBIND: ::std::os::raw::c_uint = 8;
pub const RTLD_GLOBAL: ::std::os::raw::c_uint = 256;
pub const RTLD_LOCAL: ::std::os::raw::c_uint = 0;
pub const RTLD_NODELETE: ::std::os::raw::c_uint = 4096;
pub const LM_ID_BASE: ::std::os::raw::c_uint = 0;
pub const LM_ID_NEWLM: ::std::os::raw::c_int = -1;
pub const _LIBC_LIMITS_H_: ::std::os::raw::c_uint = 1;
pub const MB_LEN_MAX: ::std::os::raw::c_uint = 16;
pub const _BITS_POSIX1_LIM_H: ::std::os::raw::c_uint = 1;
pub const _POSIX_AIO_LISTIO_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX_AIO_MAX: ::std::os::raw::c_uint = 1;
pub const _POSIX_ARG_MAX: ::std::os::raw::c_uint = 4096;
pub const _POSIX_CHILD_MAX: ::std::os::raw::c_uint = 25;
pub const _POSIX_DELAYTIMER_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_HOST_NAME_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_LINK_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_LOGIN_NAME_MAX: ::std::os::raw::c_uint = 9;
pub const _POSIX_MAX_CANON: ::std::os::raw::c_uint = 255;
pub const _POSIX_MAX_INPUT: ::std::os::raw::c_uint = 255;
pub const _POSIX_MQ_OPEN_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_MQ_PRIO_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const _POSIX_NGROUPS_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_OPEN_MAX: ::std::os::raw::c_uint = 20;
pub const _POSIX_FD_SETSIZE: ::std::os::raw::c_uint = 20;
pub const _POSIX_PATH_MAX: ::std::os::raw::c_uint = 256;
pub const _POSIX_PIPE_BUF: ::std::os::raw::c_uint = 512;
pub const _POSIX_RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_RTSIG_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_SEM_NSEMS_MAX: ::std::os::raw::c_uint = 256;
pub const _POSIX_SEM_VALUE_MAX: ::std::os::raw::c_uint = 32767;
pub const _POSIX_SIGQUEUE_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_SSIZE_MAX: ::std::os::raw::c_uint = 32767;
pub const _POSIX_STREAM_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_SYMLINK_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_SYMLOOP_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_TIMER_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_TTY_NAME_MAX: ::std::os::raw::c_uint = 9;
pub const _POSIX_TZNAME_MAX: ::std::os::raw::c_uint = 6;
pub const _POSIX_QLIMIT: ::std::os::raw::c_uint = 1;
pub const _POSIX_HIWAT: ::std::os::raw::c_uint = 512;
pub const _POSIX_UIO_MAXIOV: ::std::os::raw::c_uint = 16;
pub const _POSIX_CLOCKRES_MIN: ::std::os::raw::c_uint = 20000000;
pub const NR_OPEN: ::std::os::raw::c_uint = 1024;
pub const NGROUPS_MAX: ::std::os::raw::c_uint = 65536;
pub const ARG_MAX: ::std::os::raw::c_uint = 131072;
pub const LINK_MAX: ::std::os::raw::c_uint = 127;
pub const MAX_CANON: ::std::os::raw::c_uint = 255;
pub const MAX_INPUT: ::std::os::raw::c_uint = 255;
pub const NAME_MAX: ::std::os::raw::c_uint = 255;
pub const PATH_MAX: ::std::os::raw::c_uint = 4096;
pub const PIPE_BUF: ::std::os::raw::c_uint = 4096;
pub const XATTR_NAME_MAX: ::std::os::raw::c_uint = 255;
pub const XATTR_SIZE_MAX: ::std::os::raw::c_uint = 65536;
pub const XATTR_LIST_MAX: ::std::os::raw::c_uint = 65536;
pub const RTSIG_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_THREAD_KEYS_MAX: ::std::os::raw::c_uint = 128;
pub const PTHREAD_KEYS_MAX: ::std::os::raw::c_uint = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 4;
pub const _POSIX_THREAD_THREADS_MAX: ::std::os::raw::c_uint = 64;
pub const AIO_PRIO_DELTA_MAX: ::std::os::raw::c_uint = 20;
pub const PTHREAD_STACK_MIN: ::std::os::raw::c_uint = 16384;
pub const DELAYTIMER_MAX: ::std::os::raw::c_uint = 2147483647;
pub const TTY_NAME_MAX: ::std::os::raw::c_uint = 32;
pub const LOGIN_NAME_MAX: ::std::os::raw::c_uint = 256;
pub const HOST_NAME_MAX: ::std::os::raw::c_uint = 64;
pub const MQ_PRIO_MAX: ::std::os::raw::c_uint = 32768;
pub const SEM_VALUE_MAX: ::std::os::raw::c_uint = 2147483647;
pub const _BITS_POSIX2_LIM_H: ::std::os::raw::c_uint = 1;
pub const _POSIX2_BC_BASE_MAX: ::std::os::raw::c_uint = 99;
pub const _POSIX2_BC_DIM_MAX: ::std::os::raw::c_uint = 2048;
pub const _POSIX2_BC_SCALE_MAX: ::std::os::raw::c_uint = 99;
pub const _POSIX2_BC_STRING_MAX: ::std::os::raw::c_uint = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX2_EXPR_NEST_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX2_LINE_MAX: ::std::os::raw::c_uint = 2048;
pub const _POSIX2_RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const BC_BASE_MAX: ::std::os::raw::c_uint = 99;
pub const BC_DIM_MAX: ::std::os::raw::c_uint = 2048;
pub const BC_SCALE_MAX: ::std::os::raw::c_uint = 99;
pub const BC_STRING_MAX: ::std::os::raw::c_uint = 1000;
pub const COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 255;
pub const EXPR_NEST_MAX: ::std::os::raw::c_uint = 32;
pub const LINE_MAX: ::std::os::raw::c_uint = 2048;
pub const CHARCLASS_NAME_MAX: ::std::os::raw::c_uint = 2048;
pub const RE_DUP_MAX: ::std::os::raw::c_uint = 32767;
pub const _XOPEN_LIM_H: ::std::os::raw::c_uint = 1;
pub const IOV_MAX: ::std::os::raw::c_uint = 1024;
pub const _XOPEN_IOV_MAX: ::std::os::raw::c_uint = 16;
pub const NL_ARGMAX: ::std::os::raw::c_uint = 4096;
pub const NL_LANGMAX: ::std::os::raw::c_uint = 2048;
pub const NZERO: ::std::os::raw::c_uint = 20;
pub const WORD_BIT: ::std::os::raw::c_uint = 32;
pub const LONG_BIT: ::std::os::raw::c_uint = 64;
pub const ZEND_ENABLE_ZVAL_LONG64: ::std::os::raw::c_uint = 1;
pub const SIZEOF_ZEND_LONG: ::std::os::raw::c_uint = 8;
pub const ZEND_LTOA_BUF_LEN: ::std::os::raw::c_uint = 65;
pub const ZEND_LONG_FMT: &'static [u8; 4usize] = b"%ld\x00";
pub const ZEND_ULONG_FMT: &'static [u8; 4usize] = b"%lu\x00";
pub const ZEND_LONG_FMT_SPEC: &'static [u8; 3usize] = b"ld\x00";
pub const ZEND_ULONG_FMT_SPEC: &'static [u8; 3usize] = b"lu\x00";
pub const MAX_LENGTH_OF_LONG: ::std::os::raw::c_uint = 20;
pub const LONG_MIN_DIGITS: &'static [u8; 20usize] =
    b"9223372036854775808\x00";
pub const ZEND_LONG_CAN_OVFL_INT: ::std::os::raw::c_uint = 1;
pub const ZEND_LONG_CAN_OVFL_UINT: ::std::os::raw::c_uint = 1;
pub const ZEND_SIZE_T_CAN_OVFL_UINT: ::std::os::raw::c_uint = 1;
pub const ZEND_EXTENSIONS_SUPPORT: ::std::os::raw::c_uint = 1;
pub const ZEND_ALLOCA_MAX_SIZE: ::std::os::raw::c_uint = 32768;
pub const ZTS_V: ::std::os::raw::c_uint = 0;
pub const MAX_LENGTH_OF_DOUBLE: ::std::os::raw::c_uint = 32;
pub const ZEND_SIZE_MAX: ::std::os::raw::c_int = -1;
pub const HT_MIN_SIZE: ::std::os::raw::c_uint = 8;
pub const HT_MAX_SIZE: ::std::os::raw::c_uint = 2147483648;
pub const IS_UNDEF: ::std::os::raw::c_uint = 0;
pub const IS_NULL: ::std::os::raw::c_uint = 1;
pub const IS_FALSE: ::std::os::raw::c_uint = 2;
pub const IS_TRUE: ::std::os::raw::c_uint = 3;
pub const IS_LONG: ::std::os::raw::c_uint = 4;
pub const IS_DOUBLE: ::std::os::raw::c_uint = 5;
pub const IS_STRING: ::std::os::raw::c_uint = 6;
pub const IS_ARRAY: ::std::os::raw::c_uint = 7;
pub const IS_OBJECT: ::std::os::raw::c_uint = 8;
pub const IS_RESOURCE: ::std::os::raw::c_uint = 9;
pub const IS_REFERENCE: ::std::os::raw::c_uint = 10;
pub const IS_CONSTANT: ::std::os::raw::c_uint = 11;
pub const IS_CONSTANT_AST: ::std::os::raw::c_uint = 12;
pub const _IS_BOOL: ::std::os::raw::c_uint = 13;
pub const IS_CALLABLE: ::std::os::raw::c_uint = 14;
pub const IS_INDIRECT: ::std::os::raw::c_uint = 15;
pub const IS_PTR: ::std::os::raw::c_uint = 17;
pub const Z_TYPE_MASK: ::std::os::raw::c_uint = 255;
pub const Z_TYPE_FLAGS_SHIFT: ::std::os::raw::c_uint = 8;
pub const Z_CONST_FLAGS_SHIFT: ::std::os::raw::c_uint = 16;
pub const IS_TYPE_CONSTANT: ::std::os::raw::c_uint = 1;
pub const IS_TYPE_IMMUTABLE: ::std::os::raw::c_uint = 2;
pub const IS_TYPE_REFCOUNTED: ::std::os::raw::c_uint = 4;
pub const IS_TYPE_COLLECTABLE: ::std::os::raw::c_uint = 8;
pub const IS_TYPE_COPYABLE: ::std::os::raw::c_uint = 16;
pub const IS_TYPE_SYMBOLTABLE: ::std::os::raw::c_uint = 32;
pub const IS_INTERNED_STRING_EX: ::std::os::raw::c_uint = 6;
pub const IS_STRING_EX: ::std::os::raw::c_uint = 5126;
pub const IS_ARRAY_EX: ::std::os::raw::c_uint = 7175;
pub const IS_OBJECT_EX: ::std::os::raw::c_uint = 3080;
pub const IS_RESOURCE_EX: ::std::os::raw::c_uint = 1033;
pub const IS_REFERENCE_EX: ::std::os::raw::c_uint = 1034;
pub const IS_CONSTANT_EX: ::std::os::raw::c_uint = 5387;
pub const IS_CONSTANT_AST_EX: ::std::os::raw::c_uint = 5388;
pub const IS_CONSTANT_UNQUALIFIED: ::std::os::raw::c_uint = 16;
pub const IS_LEXICAL_VAR: ::std::os::raw::c_uint = 32;
pub const IS_LEXICAL_REF: ::std::os::raw::c_uint = 64;
pub const IS_CONSTANT_CLASS: ::std::os::raw::c_uint = 128;
pub const IS_CONSTANT_IN_NAMESPACE: ::std::os::raw::c_uint = 256;
pub const IS_VAR_RET_REF: ::std::os::raw::c_uint = 1;
pub const IS_STR_PERSISTENT: ::std::os::raw::c_uint = 1;
pub const IS_STR_INTERNED: ::std::os::raw::c_uint = 2;
pub const IS_STR_PERMANENT: ::std::os::raw::c_uint = 4;
pub const IS_STR_CONSTANT: ::std::os::raw::c_uint = 8;
pub const IS_STR_CONSTANT_UNQUALIFIED: ::std::os::raw::c_uint = 16;
pub const IS_ARRAY_IMMUTABLE: ::std::os::raw::c_uint = 2;
pub const IS_OBJ_APPLY_COUNT: ::std::os::raw::c_uint = 7;
pub const IS_OBJ_DESTRUCTOR_CALLED: ::std::os::raw::c_uint = 8;
pub const IS_OBJ_FREE_CALLED: ::std::os::raw::c_uint = 16;
pub const IS_OBJ_USE_GUARDS: ::std::os::raw::c_uint = 32;
pub const IS_OBJ_HAS_GUARDS: ::std::os::raw::c_uint = 64;
pub const E_ERROR: ::std::os::raw::c_uint = 1;
pub const E_WARNING: ::std::os::raw::c_uint = 2;
pub const E_PARSE: ::std::os::raw::c_uint = 4;
pub const E_NOTICE: ::std::os::raw::c_uint = 8;
pub const E_CORE_ERROR: ::std::os::raw::c_uint = 16;
pub const E_CORE_WARNING: ::std::os::raw::c_uint = 32;
pub const E_COMPILE_ERROR: ::std::os::raw::c_uint = 64;
pub const E_COMPILE_WARNING: ::std::os::raw::c_uint = 128;
pub const E_USER_ERROR: ::std::os::raw::c_uint = 256;
pub const E_USER_WARNING: ::std::os::raw::c_uint = 512;
pub const E_USER_NOTICE: ::std::os::raw::c_uint = 1024;
pub const E_STRICT: ::std::os::raw::c_uint = 2048;
pub const E_RECOVERABLE_ERROR: ::std::os::raw::c_uint = 4096;
pub const E_DEPRECATED: ::std::os::raw::c_uint = 8192;
pub const E_USER_DEPRECATED: ::std::os::raw::c_uint = 16384;
pub const E_ALL: ::std::os::raw::c_uint = 32767;
pub const E_CORE: ::std::os::raw::c_uint = 48;
pub const ZEND_MM_OVERHEAD: ::std::os::raw::c_uint = 0;
pub const ZEND_MM_CHUNK_SIZE: ::std::os::raw::c_uint = 2097152;
pub const ZEND_MM_PAGE_SIZE: ::std::os::raw::c_uint = 4096;
pub const ZEND_MM_PAGES: ::std::os::raw::c_uint = 512;
pub const ZEND_MM_FIRST_PAGE: ::std::os::raw::c_uint = 1;
pub const ZEND_MM_MIN_SMALL_SIZE: ::std::os::raw::c_uint = 8;
pub const ZEND_MM_MAX_SMALL_SIZE: ::std::os::raw::c_uint = 3072;
pub const ZEND_MM_MAX_LARGE_SIZE: ::std::os::raw::c_uint = 2093056;
pub const ZEND_MM_CUSTOM_HEAP_NONE: ::std::os::raw::c_uint = 0;
pub const ZEND_MM_CUSTOM_HEAP_STD: ::std::os::raw::c_uint = 1;
pub const ZEND_MM_CUSTOM_HEAP_DEBUG: ::std::os::raw::c_uint = 2;
pub const HASH_KEY_IS_STRING: ::std::os::raw::c_uint = 1;
pub const HASH_KEY_IS_LONG: ::std::os::raw::c_uint = 2;
pub const HASH_KEY_NON_EXISTENT: ::std::os::raw::c_uint = 3;
pub const HASH_UPDATE: ::std::os::raw::c_uint = 1;
pub const HASH_ADD: ::std::os::raw::c_uint = 2;
pub const HASH_UPDATE_INDIRECT: ::std::os::raw::c_uint = 4;
pub const HASH_ADD_NEW: ::std::os::raw::c_uint = 8;
pub const HASH_ADD_NEXT: ::std::os::raw::c_uint = 16;
pub const HASH_FLAG_PERSISTENT: ::std::os::raw::c_uint = 1;
pub const HASH_FLAG_APPLY_PROTECTION: ::std::os::raw::c_uint = 2;
pub const HASH_FLAG_PACKED: ::std::os::raw::c_uint = 4;
pub const HASH_FLAG_INITIALIZED: ::std::os::raw::c_uint = 8;
pub const HASH_FLAG_STATIC_KEYS: ::std::os::raw::c_uint = 16;
pub const HASH_FLAG_HAS_EMPTY_IND: ::std::os::raw::c_uint = 32;
pub const HASH_MASK_CONSISTENCY: ::std::os::raw::c_uint = 192;
pub const ZEND_HASH_APPLY_KEEP: ::std::os::raw::c_uint = 0;
pub const ZEND_HASH_APPLY_REMOVE: ::std::os::raw::c_uint = 1;
pub const ZEND_HASH_APPLY_STOP: ::std::os::raw::c_uint = 2;
pub const ZEND_HASH_APPLY_SHIFT: ::std::os::raw::c_uint = 8;
pub const ZEND_HASH_APPLY_COUNT_MASK: ::std::os::raw::c_uint = 65280;
pub const GC_BENCH: ::std::os::raw::c_uint = 0;
pub const GC_COLOR: ::std::os::raw::c_uint = 49152;
pub const GC_BLACK: ::std::os::raw::c_uint = 0;
pub const GC_WHITE: ::std::os::raw::c_uint = 32768;
pub const GC_GREY: ::std::os::raw::c_uint = 16384;
pub const GC_PURPLE: ::std::os::raw::c_uint = 49152;
pub const _SYS_STAT_H: ::std::os::raw::c_uint = 1;
pub const _BITS_STAT_H: ::std::os::raw::c_uint = 1;
pub const _STAT_VER_KERNEL: ::std::os::raw::c_uint = 0;
pub const _STAT_VER_LINUX: ::std::os::raw::c_uint = 1;
pub const _MKNOD_VER_LINUX: ::std::os::raw::c_uint = 0;
pub const _STAT_VER: ::std::os::raw::c_uint = 1;
pub const __S_IFMT: ::std::os::raw::c_uint = 61440;
pub const __S_IFDIR: ::std::os::raw::c_uint = 16384;
pub const __S_IFCHR: ::std::os::raw::c_uint = 8192;
pub const __S_IFBLK: ::std::os::raw::c_uint = 24576;
pub const __S_IFREG: ::std::os::raw::c_uint = 32768;
pub const __S_IFIFO: ::std::os::raw::c_uint = 4096;
pub const __S_IFLNK: ::std::os::raw::c_uint = 40960;
pub const __S_IFSOCK: ::std::os::raw::c_uint = 49152;
pub const __S_ISUID: ::std::os::raw::c_uint = 2048;
pub const __S_ISGID: ::std::os::raw::c_uint = 1024;
pub const __S_ISVTX: ::std::os::raw::c_uint = 512;
pub const __S_IREAD: ::std::os::raw::c_uint = 256;
pub const __S_IWRITE: ::std::os::raw::c_uint = 128;
pub const __S_IEXEC: ::std::os::raw::c_uint = 64;
pub const UTIME_NOW: ::std::os::raw::c_uint = 1073741823;
pub const UTIME_OMIT: ::std::os::raw::c_uint = 1073741822;
pub const S_IFMT: ::std::os::raw::c_uint = 61440;
pub const S_IFDIR: ::std::os::raw::c_uint = 16384;
pub const S_IFCHR: ::std::os::raw::c_uint = 8192;
pub const S_IFBLK: ::std::os::raw::c_uint = 24576;
pub const S_IFREG: ::std::os::raw::c_uint = 32768;
pub const S_IFIFO: ::std::os::raw::c_uint = 4096;
pub const S_IFLNK: ::std::os::raw::c_uint = 40960;
pub const S_IFSOCK: ::std::os::raw::c_uint = 49152;
pub const S_ISUID: ::std::os::raw::c_uint = 2048;
pub const S_ISGID: ::std::os::raw::c_uint = 1024;
pub const S_ISVTX: ::std::os::raw::c_uint = 512;
pub const S_IRUSR: ::std::os::raw::c_uint = 256;
pub const S_IWUSR: ::std::os::raw::c_uint = 128;
pub const S_IXUSR: ::std::os::raw::c_uint = 64;
pub const S_IRWXU: ::std::os::raw::c_uint = 448;
pub const S_IREAD: ::std::os::raw::c_uint = 256;
pub const S_IWRITE: ::std::os::raw::c_uint = 128;
pub const S_IEXEC: ::std::os::raw::c_uint = 64;
pub const S_IRGRP: ::std::os::raw::c_uint = 32;
pub const S_IWGRP: ::std::os::raw::c_uint = 16;
pub const S_IXGRP: ::std::os::raw::c_uint = 8;
pub const S_IRWXG: ::std::os::raw::c_uint = 56;
pub const S_IROTH: ::std::os::raw::c_uint = 4;
pub const S_IWOTH: ::std::os::raw::c_uint = 2;
pub const S_IXOTH: ::std::os::raw::c_uint = 1;
pub const S_IRWXO: ::std::os::raw::c_uint = 7;
pub const ACCESSPERMS: ::std::os::raw::c_uint = 511;
pub const ALLPERMS: ::std::os::raw::c_uint = 4095;
pub const DEFFILEMODE: ::std::os::raw::c_uint = 438;
pub const S_BLKSIZE: ::std::os::raw::c_uint = 512;
pub const _MKNOD_VER: ::std::os::raw::c_uint = 0;
pub const ZEND_MMAP_AHEAD: ::std::os::raw::c_uint = 32;
pub const OE_IS_ARRAY: ::std::os::raw::c_uint = 1;
pub const OE_IS_OBJECT: ::std::os::raw::c_uint = 2;
pub const OE_IS_METHOD: ::std::os::raw::c_uint = 4;
pub const ZMSG_FAILED_INCLUDE_FOPEN: ::std::os::raw::c_uint = 1;
pub const ZMSG_FAILED_REQUIRE_FOPEN: ::std::os::raw::c_uint = 2;
pub const ZMSG_FAILED_HIGHLIGHT_FOPEN: ::std::os::raw::c_uint = 3;
pub const ZMSG_MEMORY_LEAK_DETECTED: ::std::os::raw::c_uint = 4;
pub const ZMSG_MEMORY_LEAK_REPEATED: ::std::os::raw::c_uint = 5;
pub const ZMSG_LOG_SCRIPT_NAME: ::std::os::raw::c_uint = 6;
pub const ZMSG_MEMORY_LEAKS_GRAND_TOTAL: ::std::os::raw::c_uint = 7;
pub const DEBUG_BACKTRACE_PROVIDE_OBJECT: ::std::os::raw::c_uint = 1;
pub const DEBUG_BACKTRACE_IGNORE_ARGS: ::std::os::raw::c_uint = 2;
pub const ZEND_DYNAMIC_PROPERTY_OFFSET: ::std::os::raw::c_int = -1;
pub const ZEND_WRONG_PROPERTY_OFFSET: ::std::os::raw::c_int = -2;
pub const _ERRNO_H: ::std::os::raw::c_uint = 1;
pub const EPERM: ::std::os::raw::c_uint = 1;
pub const ENOENT: ::std::os::raw::c_uint = 2;
pub const ESRCH: ::std::os::raw::c_uint = 3;
pub const EINTR: ::std::os::raw::c_uint = 4;
pub const EIO: ::std::os::raw::c_uint = 5;
pub const ENXIO: ::std::os::raw::c_uint = 6;
pub const E2BIG: ::std::os::raw::c_uint = 7;
pub const ENOEXEC: ::std::os::raw::c_uint = 8;
pub const EBADF: ::std::os::raw::c_uint = 9;
pub const ECHILD: ::std::os::raw::c_uint = 10;
pub const EAGAIN: ::std::os::raw::c_uint = 11;
pub const ENOMEM: ::std::os::raw::c_uint = 12;
pub const EACCES: ::std::os::raw::c_uint = 13;
pub const EFAULT: ::std::os::raw::c_uint = 14;
pub const ENOTBLK: ::std::os::raw::c_uint = 15;
pub const EBUSY: ::std::os::raw::c_uint = 16;
pub const EEXIST: ::std::os::raw::c_uint = 17;
pub const EXDEV: ::std::os::raw::c_uint = 18;
pub const ENODEV: ::std::os::raw::c_uint = 19;
pub const ENOTDIR: ::std::os::raw::c_uint = 20;
pub const EISDIR: ::std::os::raw::c_uint = 21;
pub const EINVAL: ::std::os::raw::c_uint = 22;
pub const ENFILE: ::std::os::raw::c_uint = 23;
pub const EMFILE: ::std::os::raw::c_uint = 24;
pub const ENOTTY: ::std::os::raw::c_uint = 25;
pub const ETXTBSY: ::std::os::raw::c_uint = 26;
pub const EFBIG: ::std::os::raw::c_uint = 27;
pub const ENOSPC: ::std::os::raw::c_uint = 28;
pub const ESPIPE: ::std::os::raw::c_uint = 29;
pub const EROFS: ::std::os::raw::c_uint = 30;
pub const EMLINK: ::std::os::raw::c_uint = 31;
pub const EPIPE: ::std::os::raw::c_uint = 32;
pub const EDOM: ::std::os::raw::c_uint = 33;
pub const ERANGE: ::std::os::raw::c_uint = 34;
pub const EDEADLK: ::std::os::raw::c_uint = 35;
pub const ENAMETOOLONG: ::std::os::raw::c_uint = 36;
pub const ENOLCK: ::std::os::raw::c_uint = 37;
pub const ENOSYS: ::std::os::raw::c_uint = 38;
pub const ENOTEMPTY: ::std::os::raw::c_uint = 39;
pub const ELOOP: ::std::os::raw::c_uint = 40;
pub const EWOULDBLOCK: ::std::os::raw::c_uint = 11;
pub const ENOMSG: ::std::os::raw::c_uint = 42;
pub const EIDRM: ::std::os::raw::c_uint = 43;
pub const ECHRNG: ::std::os::raw::c_uint = 44;
pub const EL2NSYNC: ::std::os::raw::c_uint = 45;
pub const EL3HLT: ::std::os::raw::c_uint = 46;
pub const EL3RST: ::std::os::raw::c_uint = 47;
pub const ELNRNG: ::std::os::raw::c_uint = 48;
pub const EUNATCH: ::std::os::raw::c_uint = 49;
pub const ENOCSI: ::std::os::raw::c_uint = 50;
pub const EL2HLT: ::std::os::raw::c_uint = 51;
pub const EBADE: ::std::os::raw::c_uint = 52;
pub const EBADR: ::std::os::raw::c_uint = 53;
pub const EXFULL: ::std::os::raw::c_uint = 54;
pub const ENOANO: ::std::os::raw::c_uint = 55;
pub const EBADRQC: ::std::os::raw::c_uint = 56;
pub const EBADSLT: ::std::os::raw::c_uint = 57;
pub const EDEADLOCK: ::std::os::raw::c_uint = 35;
pub const EBFONT: ::std::os::raw::c_uint = 59;
pub const ENOSTR: ::std::os::raw::c_uint = 60;
pub const ENODATA: ::std::os::raw::c_uint = 61;
pub const ETIME: ::std::os::raw::c_uint = 62;
pub const ENOSR: ::std::os::raw::c_uint = 63;
pub const ENONET: ::std::os::raw::c_uint = 64;
pub const ENOPKG: ::std::os::raw::c_uint = 65;
pub const EREMOTE: ::std::os::raw::c_uint = 66;
pub const ENOLINK: ::std::os::raw::c_uint = 67;
pub const EADV: ::std::os::raw::c_uint = 68;
pub const ESRMNT: ::std::os::raw::c_uint = 69;
pub const ECOMM: ::std::os::raw::c_uint = 70;
pub const EPROTO: ::std::os::raw::c_uint = 71;
pub const EMULTIHOP: ::std::os::raw::c_uint = 72;
pub const EDOTDOT: ::std::os::raw::c_uint = 73;
pub const EBADMSG: ::std::os::raw::c_uint = 74;
pub const EOVERFLOW: ::std::os::raw::c_uint = 75;
pub const ENOTUNIQ: ::std::os::raw::c_uint = 76;
pub const EBADFD: ::std::os::raw::c_uint = 77;
pub const EREMCHG: ::std::os::raw::c_uint = 78;
pub const ELIBACC: ::std::os::raw::c_uint = 79;
pub const ELIBBAD: ::std::os::raw::c_uint = 80;
pub const ELIBSCN: ::std::os::raw::c_uint = 81;
pub const ELIBMAX: ::std::os::raw::c_uint = 82;
pub const ELIBEXEC: ::std::os::raw::c_uint = 83;
pub const EILSEQ: ::std::os::raw::c_uint = 84;
pub const ERESTART: ::std::os::raw::c_uint = 85;
pub const ESTRPIPE: ::std::os::raw::c_uint = 86;
pub const EUSERS: ::std::os::raw::c_uint = 87;
pub const ENOTSOCK: ::std::os::raw::c_uint = 88;
pub const EDESTADDRREQ: ::std::os::raw::c_uint = 89;
pub const EMSGSIZE: ::std::os::raw::c_uint = 90;
pub const EPROTOTYPE: ::std::os::raw::c_uint = 91;
pub const ENOPROTOOPT: ::std::os::raw::c_uint = 92;
pub const EPROTONOSUPPORT: ::std::os::raw::c_uint = 93;
pub const ESOCKTNOSUPPORT: ::std::os::raw::c_uint = 94;
pub const EOPNOTSUPP: ::std::os::raw::c_uint = 95;
pub const EPFNOSUPPORT: ::std::os::raw::c_uint = 96;
pub const EAFNOSUPPORT: ::std::os::raw::c_uint = 97;
pub const EADDRINUSE: ::std::os::raw::c_uint = 98;
pub const EADDRNOTAVAIL: ::std::os::raw::c_uint = 99;
pub const ENETDOWN: ::std::os::raw::c_uint = 100;
pub const ENETUNREACH: ::std::os::raw::c_uint = 101;
pub const ENETRESET: ::std::os::raw::c_uint = 102;
pub const ECONNABORTED: ::std::os::raw::c_uint = 103;
pub const ECONNRESET: ::std::os::raw::c_uint = 104;
pub const ENOBUFS: ::std::os::raw::c_uint = 105;
pub const EISCONN: ::std::os::raw::c_uint = 106;
pub const ENOTCONN: ::std::os::raw::c_uint = 107;
pub const ESHUTDOWN: ::std::os::raw::c_uint = 108;
pub const ETOOMANYREFS: ::std::os::raw::c_uint = 109;
pub const ETIMEDOUT: ::std::os::raw::c_uint = 110;
pub const ECONNREFUSED: ::std::os::raw::c_uint = 111;
pub const EHOSTDOWN: ::std::os::raw::c_uint = 112;
pub const EHOSTUNREACH: ::std::os::raw::c_uint = 113;
pub const EALREADY: ::std::os::raw::c_uint = 114;
pub const EINPROGRESS: ::std::os::raw::c_uint = 115;
pub const ESTALE: ::std::os::raw::c_uint = 116;
pub const EUCLEAN: ::std::os::raw::c_uint = 117;
pub const ENOTNAM: ::std::os::raw::c_uint = 118;
pub const ENAVAIL: ::std::os::raw::c_uint = 119;
pub const EISNAM: ::std::os::raw::c_uint = 120;
pub const EREMOTEIO: ::std::os::raw::c_uint = 121;
pub const EDQUOT: ::std::os::raw::c_uint = 122;
pub const ENOMEDIUM: ::std::os::raw::c_uint = 123;
pub const EMEDIUMTYPE: ::std::os::raw::c_uint = 124;
pub const ECANCELED: ::std::os::raw::c_uint = 125;
pub const ENOKEY: ::std::os::raw::c_uint = 126;
pub const EKEYEXPIRED: ::std::os::raw::c_uint = 127;
pub const EKEYREVOKED: ::std::os::raw::c_uint = 128;
pub const EKEYREJECTED: ::std::os::raw::c_uint = 129;
pub const EOWNERDEAD: ::std::os::raw::c_uint = 130;
pub const ENOTRECOVERABLE: ::std::os::raw::c_uint = 131;
pub const ERFKILL: ::std::os::raw::c_uint = 132;
pub const EHWPOISON: ::std::os::raw::c_uint = 133;
pub const ENOTSUP: ::std::os::raw::c_uint = 95;
pub const __error_t_defined: ::std::os::raw::c_uint = 1;
pub const LP_SUFF: &'static [u8; 2usize] = b"q\x00";
pub const ZEND_AST_SPECIAL_SHIFT: ::std::os::raw::c_uint = 6;
pub const ZEND_AST_IS_LIST_SHIFT: ::std::os::raw::c_uint = 7;
pub const ZEND_AST_NUM_CHILDREN_SHIFT: ::std::os::raw::c_uint = 8;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum idtype_t { P_ALL = 0, P_PID = 1, P_PGID = 2, }
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__fsid_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fsid_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct wait {
    pub w_status: __BindgenUnionField<::std::os::raw::c_int>,
    pub __wait_terminated: __BindgenUnionField<wait__bindgen_ty_1>,
    pub __wait_stopped: __BindgenUnionField<wait__bindgen_ty_2>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<wait__bindgen_ty_1>() , 4usize , concat !
               ( "Size of: " , stringify ! ( wait__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<wait__bindgen_ty_1>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_1 ) ));
}
impl Clone for wait__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn __w_termsig(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 127u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_termsig(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 127u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __w_coredump(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 128u64 as u32;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_coredump(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 128u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __w_retcode(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_retcode(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(__w_termsig: ::std::os::raw::c_uint,
                          __w_coredump: ::std::os::raw::c_uint,
                          __w_retcode: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({ 0 } |
                       ((__w_termsig as u32 as u32) << 0usize) &
                           (127u64 as u32))
              } | ((__w_coredump as u32 as u32) << 7usize) & (128u64 as u32))
         } | ((__w_retcode as u32 as u32) << 8usize) & (65280u64 as u32))
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<wait__bindgen_ty_2>() , 4usize , concat !
               ( "Size of: " , stringify ! ( wait__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<wait__bindgen_ty_2>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( wait__bindgen_ty_2 ) ));
}
impl Clone for wait__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn __w_stopval(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_stopval(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn __w_stopsig(&self) -> ::std::os::raw::c_uint {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set___w_stopsig(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(__w_stopval: ::std::os::raw::c_uint,
                          __w_stopsig: ::std::os::raw::c_uint) -> u32 {
        ({
             ({ 0 } |
                  ((__w_stopval as u32 as u32) << 0usize) & (255u64 as u32))
         } | ((__w_stopsig as u32 as u32) << 8usize) & (65280u64 as u32))
    }
}
#[test]
fn bindgen_test_layout_wait() {
    assert_eq!(::std::mem::size_of::<wait>() , 4usize , concat ! (
               "Size of: " , stringify ! ( wait ) ));
    assert_eq! (::std::mem::align_of::<wait>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( wait ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . w_status as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( w_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . __wait_terminated as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( __wait_terminated ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const wait ) ) . __wait_stopped as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( wait ) , "::" ,
                stringify ! ( __wait_stopped ) ));
}
impl Clone for wait {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __WAIT_STATUS {
    pub __uptr: __BindgenUnionField<*mut wait>,
    pub __iptr: __BindgenUnionField<*mut ::std::os::raw::c_int>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout___WAIT_STATUS() {
    assert_eq!(::std::mem::size_of::<__WAIT_STATUS>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __WAIT_STATUS ) ));
    assert_eq! (::std::mem::align_of::<__WAIT_STATUS>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __WAIT_STATUS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __WAIT_STATUS ) ) . __uptr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __WAIT_STATUS ) , "::"
                , stringify ! ( __uptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __WAIT_STATUS ) ) . __iptr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __WAIT_STATUS ) , "::"
                , stringify ! ( __iptr ) ));
}
impl Clone for __WAIT_STATUS {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(::std::mem::size_of::<div_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( div_t ) ));
    assert_eq! (::std::mem::align_of::<div_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( div_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . rem as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for div_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(::std::mem::size_of::<ldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ldiv_t ) ));
    assert_eq! (::std::mem::align_of::<ldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for ldiv_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(::std::mem::size_of::<lldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lldiv_t ) ));
    assert_eq! (::std::mem::align_of::<lldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . quot as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for lldiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtol(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(__nptr: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(::std::mem::size_of::<__locale_struct>() , 232usize , concat !
               ( "Size of: " , stringify ! ( __locale_struct ) ));
    assert_eq! (::std::mem::align_of::<__locale_struct>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( __locale_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __locales as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __locales ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_b as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_tolower as
                * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_tolower ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_toupper as
                * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_toupper ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __names as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __names ) ));
}
impl Clone for __locale_struct {
    fn clone(&self) -> Self { *self }
}
impl Default for __locale_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strtol_l(__nptr: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __base: ::std::os::raw::c_int, __loc: __locale_t)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul_l(__nptr: *const ::std::os::raw::c_char,
                     __endptr: *mut *mut ::std::os::raw::c_char,
                     __base: ::std::os::raw::c_int, __loc: __locale_t)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoll_l(__nptr: *const ::std::os::raw::c_char,
                     __endptr: *mut *mut ::std::os::raw::c_char,
                     __base: ::std::os::raw::c_int, __loc: __locale_t)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull_l(__nptr: *const ::std::os::raw::c_char,
                      __endptr: *mut *mut ::std::os::raw::c_char,
                      __base: ::std::os::raw::c_int, __loc: __locale_t)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtod_l(__nptr: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __loc: __locale_t) -> f64;
}
extern "C" {
    pub fn strtof_l(__nptr: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __loc: __locale_t) -> f32;
}
extern "C" {
    pub fn strtold_l(__nptr: *const ::std::os::raw::c_char,
                     __endptr: *mut *mut ::std::os::raw::c_char,
                     __loc: __locale_t) -> f64;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type ino64_t = __ino64_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type suseconds_t = __suseconds_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(::std::mem::size_of::<__sigset_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __sigset_t ) ));
    assert_eq! (::std::mem::align_of::<__sigset_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sigset_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigset_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigset_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __sigset_t {
    fn clone(&self) -> Self { *self }
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::std::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::std::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct fd_set {
    pub fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::std::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::std::mem::align_of::<fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const timespec, __sigmask: *const __sigset_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(__major: ::std::os::raw::c_uint,
                           __minor: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_ulonglong;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type blkcnt64_t = __blkcnt64_t;
pub type fsblkcnt64_t = __fsblkcnt64_t;
pub type fsfilcnt64_t = __fsfilcnt64_t;
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pthread_attr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 56usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<pthread_attr_t>() , 56usize , concat ! (
               "Size of: " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_attr_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(::std::mem::size_of::<__pthread_internal_list>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (::std::mem::align_of::<__pthread_internal_list>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __prev as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __next as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __next ) ));
}
impl Clone for __pthread_internal_list {
    fn clone(&self) -> Self { *self }
}
impl Default for __pthread_internal_list {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pthread_mutex_t {
    pub __data: __BindgenUnionField<pthread_mutex_t___pthread_mutex_s>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 40usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutex_t___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t___pthread_mutex_s>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t___pthread_mutex_s )
               ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t___pthread_mutex_s>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __lock as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __count as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __owner as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __nusers as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __nusers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __kind as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __spins as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __spins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __elision as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __elision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __list as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __list ) ));
}
impl Clone for pthread_mutex_t___pthread_mutex_s {
    fn clone(&self) -> Self { *self }
}
impl Default for pthread_mutex_t___pthread_mutex_s {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t>() , 40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pthread_mutexattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutexattr_t>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutexattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pthread_cond_t {
    pub __data: __BindgenUnionField<pthread_cond_t__bindgen_ty_1>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 48usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_longlong>,
    pub bindgen_union_field: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>() , 48usize
               , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) . __lock
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __futex as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __futex
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __total_seq as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __total_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __wakeup_seq as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __wakeup_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __woken_seq as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __woken_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __mutex as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __mutex
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __nwaiters as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nwaiters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __broadcast_seq as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __broadcast_seq ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pthread_cond_t__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t>() , 48usize , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pthread_condattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_condattr_t>() , 4usize , concat !
               ( "Size of: " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_condattr_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pthread_rwlock_t {
    pub __data: __BindgenUnionField<pthread_rwlock_t__bindgen_ty_1>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 56usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pthread_rwlock_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __nr_readers: ::std::os::raw::c_uint,
    pub __readers_wakeup: ::std::os::raw::c_uint,
    pub __writer_wakeup: ::std::os::raw::c_uint,
    pub __nr_readers_queued: ::std::os::raw::c_uint,
    pub __nr_writers_queued: ::std::os::raw::c_uint,
    pub __writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>() ,
               56usize , concat ! (
               "Size of: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_rwlock_t__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __lock as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_readers as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_readers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __readers_wakeup as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __readers_wakeup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writer_wakeup as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writer_wakeup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_readers_queued as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_readers_queued ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_writers_queued as * const _ as usize } , 20usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_writers_queued ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writer as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __shared as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __shared ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __rwelision as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __rwelision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad1 as * const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad2 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __flags as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __flags ) ));
}
impl Clone for pthread_rwlock_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t>() , 56usize , concat !
               ( "Size of: " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __data as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pthread_rwlockattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 8usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlockattr_t>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlockattr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pthread_barrier_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 32usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrier_t>() , 32usize , concat !
               ( "Size of: " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_barrier_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrier_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pthread_barrierattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrierattr_t>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( pthread_barrierattr_t )
               ));
    assert_eq! (::std::mem::align_of::<pthread_barrierattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_barrierattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrierattr_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(__seed: ::std::os::raw::c_uint,
                     __statebuf: *mut ::std::os::raw::c_char,
                     __statelen: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(::std::mem::size_of::<random_data>() , 48usize , concat ! (
               "Size of: " , stringify ! ( random_data ) ));
    assert_eq! (::std::mem::align_of::<random_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( random_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . fptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( fptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rptr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . state as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_type as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_deg as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_deg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_sep as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_sep ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . end_ptr as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( end_ptr ) ));
}
impl Clone for random_data {
    fn clone(&self) -> Self { *self }
}
impl Default for random_data {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: ::std::os::raw::c_uint, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(__seed: ::std::os::raw::c_uint,
                       __statebuf: *mut ::std::os::raw::c_char,
                       __statelen: usize, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut ::std::os::raw::c_char,
                      __buf: *mut random_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort)
     -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(::std::mem::size_of::<drand48_data>() , 24usize , concat ! (
               "Size of: " , stringify ! ( drand48_data ) ));
    assert_eq! (::std::mem::align_of::<drand48_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drand48_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __old_x as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __old_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __c as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __c ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __init as * const _ as
                usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __a as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __a ) ));
}
impl Clone for drand48_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: ::std::os::raw::c_long,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(__seed16v: *mut ::std::os::raw::c_ushort,
                    __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(__param: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut ::std::os::raw::c_void, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn cfree(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(__memptr: *mut *mut ::std::os::raw::c_void,
                          __alignment: usize, __size: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func:
                             ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(__func:
                       ::std::option::Option<unsafe extern "C" fn(__status:
                                                                      ::std::os::raw::c_int,
                                                                  __arg:
                                                                      *mut ::std::os::raw::c_void)>,
                   __arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn secure_getenv(__name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(__name: *const ::std::os::raw::c_char,
                  __value: *const ::std::os::raw::c_char,
                  __replace: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemp64(__template: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(__template: *mut ::std::os::raw::c_char,
                    __suffixlen: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps64(__template: *mut ::std::os::raw::c_char,
                      __suffixlen: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkostemp(__template: *mut ::std::os::raw::c_char,
                    __flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemp64(__template: *mut ::std::os::raw::c_char,
                      __flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps(__template: *mut ::std::os::raw::c_char,
                     __suffixlen: ::std::os::raw::c_int,
                     __flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkostemps64(__template: *mut ::std::os::raw::c_char,
                       __suffixlen: ::std::os::raw::c_int,
                       __flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn canonicalize_file_name(__name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn realpath(__name: *const ::std::os::raw::c_char,
                    __resolved: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void,
                                               arg2:
                                                   *const ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type comparison_fn_t = __compar_fn_t;
pub type __compar_d_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void,
                                               arg2:
                                                   *const ::std::os::raw::c_void,
                                               arg3:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn bsearch(__key: *const ::std::os::raw::c_void,
                   __base: *const ::std::os::raw::c_void, __nmemb: usize,
                   __size: usize, __compar: __compar_fn_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(__base: *mut ::std::os::raw::c_void, __nmemb: usize,
                 __size: usize, __compar: __compar_fn_t);
}
extern "C" {
    pub fn qsort_r(__base: *mut ::std::os::raw::c_void, __nmemb: usize,
                   __size: usize, __compar: __compar_d_fn_t,
                   __arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int)
     -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long,
                __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: ::std::os::raw::c_longlong,
                 __denom: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                  __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(__optionp: *mut *mut ::std::os::raw::c_char,
                     __tokens: *const *const ::std::os::raw::c_char,
                     __valuep: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setkey(__key: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn posix_openpt(__oflag: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grantpt(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlockpt(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(__fd: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ptsname_r(__fd: ::std::os::raw::c_int,
                     __buf: *mut ::std::os::raw::c_char, __buflen: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpt() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(__dest: *mut ::std::os::raw::c_void,
                  __src: *const ::std::os::raw::c_void, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void,
                   __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(__s: *mut ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(__s1: *const ::std::os::raw::c_void,
                  __s2: *const ::std::os::raw::c_void, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(__s: *const ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn rawmemchr(__s: *const ::std::os::raw::c_void,
                     __c: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memrchr(__s: *const ::std::os::raw::c_void,
                   __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const ::std::os::raw::c_char,
                  __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcoll_l(__s1: *const ::std::os::raw::c_char,
                     __s2: *const ::std::os::raw::c_char, __l: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: usize,
                     __l: __locale_t) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(__string: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const ::std::os::raw::c_char,
                   __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchrnul(__s: *const ::std::os::raw::c_char,
                     __c: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const ::std::os::raw::c_char,
                   __reject: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(__s: *const ::std::os::raw::c_char,
                  __accept: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(__s: *const ::std::os::raw::c_char,
                   __accept: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(__haystack: *const ::std::os::raw::c_char,
                  __needle: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(__s: *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(__s: *mut ::std::os::raw::c_char,
                      __delim: *const ::std::os::raw::c_char,
                      __save_ptr: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(__s: *mut ::std::os::raw::c_char,
                    __delim: *const ::std::os::raw::c_char,
                    __save_ptr: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcasestr(__haystack: *const ::std::os::raw::c_char,
                      __needle: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memmem(__haystack: *const ::std::os::raw::c_void,
                  __haystacklen: usize,
                  __needle: *const ::std::os::raw::c_void, __needlelen: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __mempcpy(__dest: *mut ::std::os::raw::c_void,
                     __src: *const ::std::os::raw::c_void, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mempcpy(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize)
     -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(__errnum: ::std::os::raw::c_int,
                      __buf: *mut ::std::os::raw::c_char, __buflen: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_l(__errnum: ::std::os::raw::c_int, __l: __locale_t)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bcopy(__src: *const ::std::os::raw::c_void,
                 __dest: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bcmp(__s1: *const ::std::os::raw::c_void,
                __s2: *const ::std::os::raw::c_void, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn index(__s: *const ::std::os::raw::c_char,
                 __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(__s1: *const ::std::os::raw::c_char,
                      __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(__s1: *const ::std::os::raw::c_char,
                       __s2: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(__s1: *const ::std::os::raw::c_char,
                        __s2: *const ::std::os::raw::c_char,
                        __loc: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(__s1: *const ::std::os::raw::c_char,
                         __s2: *const ::std::os::raw::c_char, __n: usize,
                         __loc: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsep(__stringp: *mut *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(__dest: *mut ::std::os::raw::c_char,
                    __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strverscmp(__s1: *const ::std::os::raw::c_char,
                      __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strfry(__string: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memfrob(__s: *mut ::std::os::raw::c_void, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn basename(__filename: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn sincos(__x: f64, __sinx: *mut f64, __cosx: *mut f64);
}
extern "C" {
    pub fn __sincos(__x: f64, __sinx: *mut f64, __cosx: *mut f64);
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn exp10(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp10(__x: f64) -> f64;
}
extern "C" {
    pub fn pow10(__x: f64) -> f64;
}
extern "C" {
    pub fn __pow10(__x: f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int)
     -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int)
     -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int)
     -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn sincosf(__x: f32, __sinx: *mut f32, __cosx: *mut f32);
}
extern "C" {
    pub fn __sincosf(__x: f32, __sinx: *mut f32, __cosx: *mut f32);
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn exp10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp10f(__x: f32) -> f32;
}
extern "C" {
    pub fn pow10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __pow10f(__x: f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int)
     -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int)
     -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: f64) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: f64) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int)
     -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int)
     -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn acosl(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosl(__x: f64) -> f64;
}
extern "C" {
    pub fn asinl(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinl(__x: f64) -> f64;
}
extern "C" {
    pub fn atanl(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanl(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2l(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2l(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cosl(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosl(__x: f64) -> f64;
}
extern "C" {
    pub fn sinl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinl(__x: f64) -> f64;
}
extern "C" {
    pub fn tanl(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanl(__x: f64) -> f64;
}
extern "C" {
    pub fn coshl(__x: f64) -> f64;
}
extern "C" {
    pub fn __coshl(__x: f64) -> f64;
}
extern "C" {
    pub fn sinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn tanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn sincosl(__x: f64, __sinx: *mut f64, __cosx: *mut f64);
}
extern "C" {
    pub fn __sincosl(__x: f64, __sinx: *mut f64, __cosx: *mut f64);
}
extern "C" {
    pub fn acoshl(__x: f64) -> f64;
}
extern "C" {
    pub fn __acoshl(__x: f64) -> f64;
}
extern "C" {
    pub fn asinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn atanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn expl(__x: f64) -> f64;
}
extern "C" {
    pub fn __expl(__x: f64) -> f64;
}
extern "C" {
    pub fn frexpl(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexpl(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexpl(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexpl(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn logl(__x: f64) -> f64;
}
extern "C" {
    pub fn __logl(__x: f64) -> f64;
}
extern "C" {
    pub fn log10l(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10l(__x: f64) -> f64;
}
extern "C" {
    pub fn modfl(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modfl(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn exp10l(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp10l(__x: f64) -> f64;
}
extern "C" {
    pub fn pow10l(__x: f64) -> f64;
}
extern "C" {
    pub fn __pow10l(__x: f64) -> f64;
}
extern "C" {
    pub fn expm1l(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1l(__x: f64) -> f64;
}
extern "C" {
    pub fn log1pl(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1pl(__x: f64) -> f64;
}
extern "C" {
    pub fn logbl(__x: f64) -> f64;
}
extern "C" {
    pub fn __logbl(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2l(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2l(__x: f64) -> f64;
}
extern "C" {
    pub fn log2l(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2l(__x: f64) -> f64;
}
extern "C" {
    pub fn powl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __powl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn hypotl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypotl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn ceill(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceill(__x: f64) -> f64;
}
extern "C" {
    pub fn fabsl(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabsl(__x: f64) -> f64;
}
extern "C" {
    pub fn floorl(__x: f64) -> f64;
}
extern "C" {
    pub fn __floorl(__x: f64) -> f64;
}
extern "C" {
    pub fn fmodl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmodl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __isinfl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitel(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isinfl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitel(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dreml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __dreml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significandl(__x: f64) -> f64;
}
extern "C" {
    pub fn __significandl(__x: f64) -> f64;
}
extern "C" {
    pub fn copysignl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysignl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __isnanl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isnanl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn gammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int)
     -> f64;
}
extern "C" {
    pub fn __lgammal_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int)
     -> f64;
}
extern "C" {
    pub fn rintl(__x: f64) -> f64;
}
extern "C" {
    pub fn __rintl(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafterl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttowardl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nexttowardl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn remainderl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainderl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbnl(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbnl(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogbl(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnl(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalblnl(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyintl(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyintl(__x: f64) -> f64;
}
extern "C" {
    pub fn roundl(__x: f64) -> f64;
}
extern "C" {
    pub fn __roundl(__x: f64) -> f64;
}
extern "C" {
    pub fn truncl(__x: f64) -> f64;
}
extern "C" {
    pub fn __truncl(__x: f64) -> f64;
}
extern "C" {
    pub fn remquol(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int)
     -> f64;
}
extern "C" {
    pub fn __remquol(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int)
     -> f64;
}
extern "C" {
    pub fn lrintl(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintl(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintl(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundl(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundl(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdiml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmaxl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fminl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fminl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fmal(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fmal(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __issignalingl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbl(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalbl(__x: f64, __n: f64) -> f64;
}
extern "C" {
    #[link_name = "signgam"]
    pub static mut signgam: ::std::os::raw::c_int;
}
pub const FP_NAN: _bindgen_ty_1 = _bindgen_ty_1::FP_NAN;
pub const FP_INFINITE: _bindgen_ty_1 = _bindgen_ty_1::FP_INFINITE;
pub const FP_ZERO: _bindgen_ty_1 = _bindgen_ty_1::FP_ZERO;
pub const FP_SUBNORMAL: _bindgen_ty_1 = _bindgen_ty_1::FP_SUBNORMAL;
pub const FP_NORMAL: _bindgen_ty_1 = _bindgen_ty_1::FP_NORMAL;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _LIB_VERSION_TYPE {
    _IEEE_ = -1,
    _SVID_ = 0,
    _XOPEN_ = 1,
    _POSIX_ = 2,
    _ISOC_ = 3,
}
extern "C" {
    #[link_name = "_LIB_VERSION"]
    pub static mut _LIB_VERSION: _LIB_VERSION_TYPE;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct exception {
    pub type_: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[test]
fn bindgen_test_layout_exception() {
    assert_eq!(::std::mem::size_of::<exception>() , 40usize , concat ! (
               "Size of: " , stringify ! ( exception ) ));
    assert_eq! (::std::mem::align_of::<exception>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( exception ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exception ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( exception ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exception ) ) . name as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( exception ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exception ) ) . arg1 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( exception ) , "::" ,
                stringify ! ( arg1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exception ) ) . arg2 as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( exception ) , "::" ,
                stringify ! ( arg2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exception ) ) . retval as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( exception ) , "::" ,
                stringify ! ( retval ) ));
}
impl Clone for exception {
    fn clone(&self) -> Self { *self }
}
impl Default for exception {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn matherr(__exc: *mut exception) -> ::std::os::raw::c_int;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(::std::mem::size_of::<imaxdiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( imaxdiv_t ) ));
    assert_eq! (::std::mem::align_of::<imaxdiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( imaxdiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const imaxdiv_t ) ) . quot as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( imaxdiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const imaxdiv_t ) ) . rem as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( imaxdiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for imaxdiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(__nptr: *const ::std::os::raw::c_char,
                     __endptr: *mut *mut ::std::os::raw::c_char,
                     __base: ::std::os::raw::c_int) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(__nptr: *const ::std::os::raw::c_char,
                     __endptr: *mut *mut ::std::os::raw::c_char,
                     __base: ::std::os::raw::c_int) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(__nptr: *const __gwchar_t,
                     __endptr: *mut *mut __gwchar_t,
                     __base: ::std::os::raw::c_int) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(__nptr: *const __gwchar_t,
                     __endptr: *mut *mut __gwchar_t,
                     __base: ::std::os::raw::c_int) -> uintmax_t;
}
pub type tsrm_intptr_t = isize;
pub type tsrm_uintptr_t = usize;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(::std::mem::size_of::<_IO_FILE>() , 216usize , concat ! (
               "Size of: " , stringify ! ( _IO_FILE ) ));
    assert_eq! (::std::mem::align_of::<_IO_FILE>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _IO_FILE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _flags as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_ptr as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_end as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_read_base as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_read_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_base as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_ptr as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_write_end as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_write_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_base as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_buf_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_buf_end as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_buf_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_base as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_save_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_backup_base as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_backup_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _IO_save_end as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _IO_save_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _markers as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _markers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _chain as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _chain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _fileno as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _fileno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _flags2 as * const _ as
                usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _flags2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _old_offset as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _old_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _cur_column as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _cur_column ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _vtable_offset as * const
                _ as usize } , 130usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _vtable_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _shortbuf as * const _ as
                usize } , 131usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _shortbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _lock as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _offset as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad1 as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad2 as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad3 as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad4 as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . __pad5 as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( __pad5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _mode as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_FILE ) ) . _unused2 as * const _ as
                usize } , 196usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_FILE ) , "::" ,
                stringify ! ( _unused2 ) ));
}
impl Clone for _IO_FILE {
    fn clone(&self) -> Self { *self }
}
impl Default for _IO_FILE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FILE = _IO_FILE;
pub type __FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __mbstate_t__bindgen_ty_1 {
    pub __wch: __BindgenUnionField<::std::os::raw::c_uint>,
    pub __wchb: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<__mbstate_t__bindgen_ty_1>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( __mbstate_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wch as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t__bindgen_ty_1 ) ) . __wchb as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wchb )
                ));
}
impl Clone for __mbstate_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __value as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __value ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(::std::mem::size_of::<_G_fpos_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _G_fpos_t ) ));
    assert_eq! (::std::mem::align_of::<_G_fpos_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _G_fpos_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos_t ) ) . __pos as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos_t ) , "::" ,
                stringify ! ( __pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos_t ) ) . __state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos_t ) , "::" ,
                stringify ! ( __state ) ));
}
impl Clone for _G_fpos_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(::std::mem::size_of::<_G_fpos64_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _G_fpos64_t ) ));
    assert_eq! (::std::mem::align_of::<_G_fpos64_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _G_fpos64_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos64_t ) ) . __pos as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos64_t ) , "::" ,
                stringify ! ( __pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _G_fpos64_t ) ) . __state as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _G_fpos64_t ) , "::" ,
                stringify ! ( __state ) ));
}
impl Clone for _G_fpos64_t {
    fn clone(&self) -> Self { *self }
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(::std::mem::size_of::<_IO_marker>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _IO_marker ) ));
    assert_eq! (::std::mem::align_of::<_IO_marker>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _IO_marker ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _sbuf as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _sbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_marker ) ) . _pos as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _IO_marker ) , "::" ,
                stringify ! ( _pos ) ));
}
impl Clone for _IO_marker {
    fn clone(&self) -> Self { *self }
}
impl Default for _IO_marker {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum __codecvt_result {
    __codecvt_ok = 0,
    __codecvt_partial = 1,
    __codecvt_error = 2,
    __codecvt_noconv = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "_IO_2_1_stdin_"]
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stdout_"]
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stderr_"]
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __buf:
                                                   *mut ::std::os::raw::c_char,
                                               __nbytes: usize) -> __ssize_t>;
pub type __io_write_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __buf:
                                                   *const ::std::os::raw::c_char,
                                               __n: usize) -> __ssize_t>;
pub type __io_seek_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __pos: *mut __off64_t,
                                               __w: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
pub type __io_close_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type cookie_read_function_t = __io_read_fn;
pub type cookie_write_function_t = __io_write_fn;
pub type cookie_seek_function_t = __io_seek_fn;
pub type cookie_close_function_t = __io_close_fn;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_cookie_io_functions_t {
    pub read: __io_read_fn,
    pub write: __io_write_fn,
    pub seek: __io_seek_fn,
    pub close: __io_close_fn,
}
#[test]
fn bindgen_test_layout__IO_cookie_io_functions_t() {
    assert_eq!(::std::mem::size_of::<_IO_cookie_io_functions_t>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( _IO_cookie_io_functions_t ) ));
    assert_eq! (::std::mem::align_of::<_IO_cookie_io_functions_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _IO_cookie_io_functions_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_cookie_io_functions_t ) ) . read as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _IO_cookie_io_functions_t ) , "::" , stringify ! ( read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_cookie_io_functions_t ) ) . write as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _IO_cookie_io_functions_t ) , "::" , stringify ! ( write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_cookie_io_functions_t ) ) . seek as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                _IO_cookie_io_functions_t ) , "::" , stringify ! ( seek ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _IO_cookie_io_functions_t ) ) . close as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                _IO_cookie_io_functions_t ) , "::" , stringify ! ( close ) ));
}
impl Clone for _IO_cookie_io_functions_t {
    fn clone(&self) -> Self { *self }
}
impl Default for _IO_cookie_io_functions_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_file {
    _unused: [u8; 0],
}
extern "C" {
    pub fn _IO_cookie_init(__cfile: *mut _IO_cookie_file,
                           __read_write: ::std::os::raw::c_int,
                           __cookie: *mut ::std::os::raw::c_void,
                           __fns: _IO_cookie_io_functions_t);
}
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(arg1: *mut _IO_FILE,
                       arg2: *const ::std::os::raw::c_char,
                       arg3: *mut __va_list_tag,
                       arg4: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(arg1: *mut _IO_FILE,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int,
                    arg3: __ssize_t) -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void,
                     arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int,
                       arg4: ::std::os::raw::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type fpos_t = _G_fpos_t;
pub type fpos64_t = _G_fpos64_t;
extern "C" {
    #[link_name = "stdin"]
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stdout"]
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stderr"]
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(__old: *const ::std::os::raw::c_char,
                  __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(__oldfd: ::std::os::raw::c_int,
                    __old: *const ::std::os::raw::c_char,
                    __newfd: ::std::os::raw::c_int,
                    __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpfile64() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(__dir: *const ::std::os::raw::c_char,
                   __pfx: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(__filename: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(__filename: *const ::std::os::raw::c_char,
                   __modes: *const ::std::os::raw::c_char,
                   __stream: *mut FILE) -> *mut FILE;
}
extern "C" {
    pub fn fopen64(__filename: *const ::std::os::raw::c_char,
                   __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen64(__filename: *const ::std::os::raw::c_char,
                     __modes: *const ::std::os::raw::c_char,
                     __stream: *mut FILE) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int,
                  __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fopencookie(__magic_cookie: *mut ::std::os::raw::c_void,
                       __modes: *const ::std::os::raw::c_char,
                       __io_funcs: _IO_cookie_io_functions_t) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(__s: *mut ::std::os::raw::c_void, __len: usize,
                    __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufloc: *mut *mut ::std::os::raw::c_char,
                          __sizeloc: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                   __modes: ::std::os::raw::c_int, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                     __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(__s: *mut ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(__format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(__s: *mut ::std::os::raw::c_char,
                    __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(__s: *mut ::std::os::raw::c_char, __maxlen: usize,
                    __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(__s: *mut ::std::os::raw::c_char, __maxlen: usize,
                     __format: *const ::std::os::raw::c_char,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(__ptr: *mut *mut ::std::os::raw::c_char,
                     __f: *const ::std::os::raw::c_char,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __asprintf(__ptr: *mut *mut ::std::os::raw::c_char,
                      __fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asprintf(__ptr: *mut *mut ::std::os::raw::c_char,
                    __fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(__fd: ::std::os::raw::c_int,
                    __fmt: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(__fd: ::std::os::raw::c_int,
                   __fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(__s: *const ::std::os::raw::c_char,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const ::std::os::raw::c_char,
                  __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(__s: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(__s: *mut ::std::os::raw::c_char, __n: ::std::os::raw::c_int,
                 __stream: *mut FILE) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgets_unlocked(__s: *mut ::std::os::raw::c_char,
                          __n: ::std::os::raw::c_int, __stream: *mut FILE)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                      __n: *mut usize, __delimiter: ::std::os::raw::c_int,
                      __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                    __n: *mut usize, __delimiter: ::std::os::raw::c_int,
                    __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn getline(__lineptr: *mut *mut ::std::os::raw::c_char,
                   __n: *mut usize, __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                 __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite(__ptr: *const ::std::os::raw::c_void, __size: usize,
                  __n: usize, __s: *mut FILE) -> usize;
}
extern "C" {
    pub fn fputs_unlocked(__s: *const ::std::os::raw::c_char,
                          __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread_unlocked(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                          __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(__ptr: *const ::std::os::raw::c_void,
                           __size: usize, __n: usize, __stream: *mut FILE)
     -> usize;
}
extern "C" {
    pub fn fseek(__stream: *mut FILE, __off: ::std::os::raw::c_long,
                 __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __off: __off_t,
                  __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseeko64(__stream: *mut FILE, __off: __off64_t,
                    __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello64(__stream: *mut FILE) -> __off64_t;
}
extern "C" {
    pub fn fgetpos64(__stream: *mut FILE, __pos: *mut fpos64_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos64(__stream: *mut FILE, __pos: *const fpos64_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "sys_nerr"]
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "_sys_nerr"]
    pub static mut _sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_sys_errlist"]
    pub static mut _sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(__command: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cuserid(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obstack {
    _unused: [u8; 0],
}
extern "C" {
    pub fn obstack_printf(__obstack: *mut obstack,
                          __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn obstack_vprintf(__obstack: *mut obstack,
                           __format: *const ::std::os::raw::c_char,
                           __args: *mut __va_list_tag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __assert_fail(__assertion: *const ::std::os::raw::c_char,
                         __file: *const ::std::os::raw::c_char,
                         __line: ::std::os::raw::c_uint,
                         __function: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn __assert_perror_fail(__errnum: ::std::os::raw::c_int,
                                __file: *const ::std::os::raw::c_char,
                                __line: ::std::os::raw::c_uint,
                                __function: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn __assert(__assertion: *const ::std::os::raw::c_char,
                    __file: *const ::std::os::raw::c_char,
                    __line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _dl_mcount_wrapper_check(__selfpc: *mut ::std::os::raw::c_void);
}
pub type Lmid_t = ::std::os::raw::c_long;
extern "C" {
    pub fn dlopen(__file: *const ::std::os::raw::c_char,
                  __mode: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dlclose(__handle: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dlsym(__handle: *mut ::std::os::raw::c_void,
                 __name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dlmopen(__nsid: Lmid_t, __file: *const ::std::os::raw::c_char,
                   __mode: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dlvsym(__handle: *mut ::std::os::raw::c_void,
                  __name: *const ::std::os::raw::c_char,
                  __version: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dlerror() -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Dl_info {
    pub dli_fname: *const ::std::os::raw::c_char,
    pub dli_fbase: *mut ::std::os::raw::c_void,
    pub dli_sname: *const ::std::os::raw::c_char,
    pub dli_saddr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_Dl_info() {
    assert_eq!(::std::mem::size_of::<Dl_info>() , 32usize , concat ! (
               "Size of: " , stringify ! ( Dl_info ) ));
    assert_eq! (::std::mem::align_of::<Dl_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Dl_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Dl_info ) ) . dli_fname as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Dl_info ) , "::" ,
                stringify ! ( dli_fname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Dl_info ) ) . dli_fbase as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Dl_info ) , "::" ,
                stringify ! ( dli_fbase ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Dl_info ) ) . dli_sname as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Dl_info ) , "::" ,
                stringify ! ( dli_sname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Dl_info ) ) . dli_saddr as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( Dl_info ) , "::" ,
                stringify ! ( dli_saddr ) ));
}
impl Clone for Dl_info {
    fn clone(&self) -> Self { *self }
}
impl Default for Dl_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn dladdr(__address: *const ::std::os::raw::c_void,
                  __info: *mut Dl_info) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dladdr1(__address: *const ::std::os::raw::c_void,
                   __info: *mut Dl_info,
                   __extra_info: *mut *mut ::std::os::raw::c_void,
                   __flags: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub const RTLD_DL_SYMENT: _bindgen_ty_2 = _bindgen_ty_2::RTLD_DL_SYMENT;
pub const RTLD_DL_LINKMAP: _bindgen_ty_2 = _bindgen_ty_2::RTLD_DL_LINKMAP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 { RTLD_DL_SYMENT = 1, RTLD_DL_LINKMAP = 2, }
extern "C" {
    pub fn dlinfo(__handle: *mut ::std::os::raw::c_void,
                  __request: ::std::os::raw::c_int,
                  __arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
pub const RTLD_DI_LMID: _bindgen_ty_3 = _bindgen_ty_3::RTLD_DI_LMID;
pub const RTLD_DI_LINKMAP: _bindgen_ty_3 = _bindgen_ty_3::RTLD_DI_LINKMAP;
pub const RTLD_DI_CONFIGADDR: _bindgen_ty_3 =
    _bindgen_ty_3::RTLD_DI_CONFIGADDR;
pub const RTLD_DI_SERINFO: _bindgen_ty_3 = _bindgen_ty_3::RTLD_DI_SERINFO;
pub const RTLD_DI_SERINFOSIZE: _bindgen_ty_3 =
    _bindgen_ty_3::RTLD_DI_SERINFOSIZE;
pub const RTLD_DI_ORIGIN: _bindgen_ty_3 = _bindgen_ty_3::RTLD_DI_ORIGIN;
pub const RTLD_DI_PROFILENAME: _bindgen_ty_3 =
    _bindgen_ty_3::RTLD_DI_PROFILENAME;
pub const RTLD_DI_PROFILEOUT: _bindgen_ty_3 =
    _bindgen_ty_3::RTLD_DI_PROFILEOUT;
pub const RTLD_DI_TLS_MODID: _bindgen_ty_3 = _bindgen_ty_3::RTLD_DI_TLS_MODID;
pub const RTLD_DI_TLS_DATA: _bindgen_ty_3 = _bindgen_ty_3::RTLD_DI_TLS_DATA;
pub const RTLD_DI_MAX: _bindgen_ty_3 = _bindgen_ty_3::RTLD_DI_TLS_DATA;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_3 {
    RTLD_DI_LMID = 1,
    RTLD_DI_LINKMAP = 2,
    RTLD_DI_CONFIGADDR = 3,
    RTLD_DI_SERINFO = 4,
    RTLD_DI_SERINFOSIZE = 5,
    RTLD_DI_ORIGIN = 6,
    RTLD_DI_PROFILENAME = 7,
    RTLD_DI_PROFILEOUT = 8,
    RTLD_DI_TLS_MODID = 9,
    RTLD_DI_TLS_DATA = 10,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Dl_serpath {
    pub dls_name: *mut ::std::os::raw::c_char,
    pub dls_flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_Dl_serpath() {
    assert_eq!(::std::mem::size_of::<Dl_serpath>() , 16usize , concat ! (
               "Size of: " , stringify ! ( Dl_serpath ) ));
    assert_eq! (::std::mem::align_of::<Dl_serpath>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Dl_serpath ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Dl_serpath ) ) . dls_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Dl_serpath ) , "::" ,
                stringify ! ( dls_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Dl_serpath ) ) . dls_flags as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Dl_serpath ) , "::" ,
                stringify ! ( dls_flags ) ));
}
impl Clone for Dl_serpath {
    fn clone(&self) -> Self { *self }
}
impl Default for Dl_serpath {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Dl_serinfo {
    pub dls_size: usize,
    pub dls_cnt: ::std::os::raw::c_uint,
    pub dls_serpath: [Dl_serpath; 1usize],
}
#[test]
fn bindgen_test_layout_Dl_serinfo() {
    assert_eq!(::std::mem::size_of::<Dl_serinfo>() , 32usize , concat ! (
               "Size of: " , stringify ! ( Dl_serinfo ) ));
    assert_eq! (::std::mem::align_of::<Dl_serinfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Dl_serinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Dl_serinfo ) ) . dls_size as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Dl_serinfo ) , "::" ,
                stringify ! ( dls_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Dl_serinfo ) ) . dls_cnt as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Dl_serinfo ) , "::" ,
                stringify ! ( dls_cnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Dl_serinfo ) ) . dls_serpath as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Dl_serinfo ) , "::" ,
                stringify ! ( dls_serpath ) ));
}
impl Clone for Dl_serinfo {
    fn clone(&self) -> Self { *self }
}
impl Default for Dl_serinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type zend_long = i64;
pub type zend_ulong = u64;
pub type zend_off_t = i64;
extern "C" {
    #[link_name = "long_min_digits"]
    pub static mut long_min_digits: [::std::os::raw::c_char; 20usize];
}
pub type zend_bool = ::std::os::raw::c_uchar;
pub type zend_uchar = ::std::os::raw::c_uchar;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ZEND_RESULT_CODE { SUCCESS = 0, FAILURE = -1, }
pub type zend_intptr_t = isize;
pub type zend_uintptr_t = usize;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _zend_object_handlers {
    pub offset: ::std::os::raw::c_int,
    pub free_obj: zend_object_free_obj_t,
    pub dtor_obj: zend_object_dtor_obj_t,
    pub clone_obj: zend_object_clone_obj_t,
    pub read_property: zend_object_read_property_t,
    pub write_property: zend_object_write_property_t,
    pub read_dimension: zend_object_read_dimension_t,
    pub write_dimension: zend_object_write_dimension_t,
    pub get_property_ptr_ptr: zend_object_get_property_ptr_ptr_t,
    pub get: zend_object_get_t,
    pub set: zend_object_set_t,
    pub has_property: zend_object_has_property_t,
    pub unset_property: zend_object_unset_property_t,
    pub has_dimension: zend_object_has_dimension_t,
    pub unset_dimension: zend_object_unset_dimension_t,
    pub get_properties: zend_object_get_properties_t,
    pub get_method: zend_object_get_method_t,
    pub call_method: zend_object_call_method_t,
    pub get_constructor: zend_object_get_constructor_t,
    pub get_class_name: zend_object_get_class_name_t,
    pub compare_objects: zend_object_compare_t,
    pub cast_object: zend_object_cast_t,
    pub count_elements: zend_object_count_elements_t,
    pub get_debug_info: zend_object_get_debug_info_t,
    pub get_closure: zend_object_get_closure_t,
    pub get_gc: zend_object_get_gc_t,
    pub do_operation: zend_object_do_operation_t,
    pub compare: zend_object_compare_zvals_t,
}
#[test]
fn bindgen_test_layout__zend_object_handlers() {
    assert_eq!(::std::mem::size_of::<_zend_object_handlers>() , 224usize ,
               concat ! ( "Size of: " , stringify ! ( _zend_object_handlers )
               ));
    assert_eq! (::std::mem::align_of::<_zend_object_handlers>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _zend_object_handlers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_handlers ) ) . offset as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object_handlers )
                , "::" , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_handlers ) ) . free_obj as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object_handlers )
                , "::" , stringify ! ( free_obj ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_handlers ) ) . dtor_obj as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object_handlers )
                , "::" , stringify ! ( dtor_obj ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_handlers ) ) . clone_obj as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object_handlers )
                , "::" , stringify ! ( clone_obj ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_handlers ) ) . read_property
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object_handlers )
                , "::" , stringify ! ( read_property ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_handlers ) ) .
                write_property as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object_handlers )
                , "::" , stringify ! ( write_property ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_handlers ) ) .
                read_dimension as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object_handlers )
                , "::" , stringify ! ( read_dimension ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_handlers ) ) .
                write_dimension as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object_handlers )
                , "::" , stringify ! ( write_dimension ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_handlers ) ) .
                get_property_ptr_ptr as * const _ as usize } , 64usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _zend_object_handlers )
                , "::" , stringify ! ( get_property_ptr_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_handlers ) ) . get as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object_handlers )
                , "::" , stringify ! ( get ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_handlers ) ) . set as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object_handlers )
                , "::" , stringify ! ( set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_handlers ) ) . has_property
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object_handlers )
                , "::" , stringify ! ( has_property ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_handlers ) ) .
                unset_property as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object_handlers )
                , "::" , stringify ! ( unset_property ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_handlers ) ) . has_dimension
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object_handlers )
                , "::" , stringify ! ( has_dimension ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_handlers ) ) .
                unset_dimension as * const _ as usize } , 112usize , concat !
                (
                "Alignment of field: " , stringify ! ( _zend_object_handlers )
                , "::" , stringify ! ( unset_dimension ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_handlers ) ) .
                get_properties as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object_handlers )
                , "::" , stringify ! ( get_properties ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_handlers ) ) . get_method as
                * const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object_handlers )
                , "::" , stringify ! ( get_method ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_handlers ) ) . call_method
                as * const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object_handlers )
                , "::" , stringify ! ( call_method ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_handlers ) ) .
                get_constructor as * const _ as usize } , 144usize , concat !
                (
                "Alignment of field: " , stringify ! ( _zend_object_handlers )
                , "::" , stringify ! ( get_constructor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_handlers ) ) .
                get_class_name as * const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object_handlers )
                , "::" , stringify ! ( get_class_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_handlers ) ) .
                compare_objects as * const _ as usize } , 160usize , concat !
                (
                "Alignment of field: " , stringify ! ( _zend_object_handlers )
                , "::" , stringify ! ( compare_objects ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_handlers ) ) . cast_object
                as * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object_handlers )
                , "::" , stringify ! ( cast_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_handlers ) ) .
                count_elements as * const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object_handlers )
                , "::" , stringify ! ( count_elements ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_handlers ) ) .
                get_debug_info as * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object_handlers )
                , "::" , stringify ! ( get_debug_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_handlers ) ) . get_closure
                as * const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object_handlers )
                , "::" , stringify ! ( get_closure ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_handlers ) ) . get_gc as *
                const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object_handlers )
                , "::" , stringify ! ( get_gc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_handlers ) ) . do_operation
                as * const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object_handlers )
                , "::" , stringify ! ( do_operation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_handlers ) ) . compare as *
                const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object_handlers )
                , "::" , stringify ! ( compare ) ));
}
impl Clone for _zend_object_handlers {
    fn clone(&self) -> Self { *self }
}
impl Default for _zend_object_handlers {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type zend_object_handlers = _zend_object_handlers;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _zend_class_entry {
    pub type_: ::std::os::raw::c_char,
    pub name: *mut zend_string,
    pub parent: *mut _zend_class_entry,
    pub refcount: ::std::os::raw::c_int,
    pub ce_flags: u32,
    pub default_properties_count: ::std::os::raw::c_int,
    pub default_static_members_count: ::std::os::raw::c_int,
    pub default_properties_table: *mut zval,
    pub default_static_members_table: *mut zval,
    pub static_members_table: *mut zval,
    pub function_table: HashTable,
    pub properties_info: HashTable,
    pub constants_table: HashTable,
    pub constructor: *mut _zend_function,
    pub destructor: *mut _zend_function,
    pub clone: *mut _zend_function,
    pub __get: *mut _zend_function,
    pub __set: *mut _zend_function,
    pub __unset: *mut _zend_function,
    pub __isset: *mut _zend_function,
    pub __call: *mut _zend_function,
    pub __callstatic: *mut _zend_function,
    pub __tostring: *mut _zend_function,
    pub __debugInfo: *mut _zend_function,
    pub serialize_func: *mut _zend_function,
    pub unserialize_func: *mut _zend_function,
    pub iterator_funcs: zend_class_iterator_funcs,
    pub create_object: ::std::option::Option<unsafe extern "C" fn(class_type:
                                                                      *mut zend_class_entry)
                                                 -> *mut zend_object>,
    pub get_iterator: ::std::option::Option<unsafe extern "C" fn(ce:
                                                                     *mut zend_class_entry,
                                                                 object:
                                                                     *mut zval,
                                                                 by_ref:
                                                                     ::std::os::raw::c_int)
                                                -> *mut zend_object_iterator>,
    pub interface_gets_implemented: ::std::option::Option<unsafe extern "C" fn(iface:
                                                                                   *mut zend_class_entry,
                                                                               class_type:
                                                                                   *mut zend_class_entry)
                                                              ->
                                                                  ::std::os::raw::c_int>,
    pub get_static_method: ::std::option::Option<unsafe extern "C" fn(ce:
                                                                          *mut zend_class_entry,
                                                                      method:
                                                                          *mut zend_string)
                                                     -> *mut _zend_function>,
    pub serialize: ::std::option::Option<unsafe extern "C" fn(object:
                                                                  *mut zval,
                                                              buffer:
                                                                  *mut *mut ::std::os::raw::c_uchar,
                                                              buf_len:
                                                                  *mut usize,
                                                              data:
                                                                  *mut zend_serialize_data)
                                             -> ::std::os::raw::c_int>,
    pub unserialize: ::std::option::Option<unsafe extern "C" fn(object:
                                                                    *mut zval,
                                                                ce:
                                                                    *mut zend_class_entry,
                                                                buf:
                                                                    *const ::std::os::raw::c_uchar,
                                                                buf_len:
                                                                    usize,
                                                                data:
                                                                    *mut zend_unserialize_data)
                                               -> ::std::os::raw::c_int>,
    pub num_interfaces: u32,
    pub num_traits: u32,
    pub interfaces: *mut *mut zend_class_entry,
    pub traits: *mut *mut zend_class_entry,
    pub trait_aliases: *mut *mut zend_trait_alias,
    pub trait_precedences: *mut *mut zend_trait_precedence,
    pub info: _zend_class_entry__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _zend_class_entry__bindgen_ty_1 {
    pub user: __BindgenUnionField<_zend_class_entry__bindgen_ty_1__bindgen_ty_1>,
    pub internal: __BindgenUnionField<_zend_class_entry__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _zend_class_entry__bindgen_ty_1__bindgen_ty_1 {
    pub filename: *mut zend_string,
    pub line_start: u32,
    pub line_end: u32,
    pub doc_comment: *mut zend_string,
}
#[test]
fn bindgen_test_layout__zend_class_entry__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_zend_class_entry__bindgen_ty_1__bindgen_ty_1>()
               , 24usize , concat ! (
               "Size of: " , stringify ! (
               _zend_class_entry__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<_zend_class_entry__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                _zend_class_entry__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const _zend_class_entry__bindgen_ty_1__bindgen_ty_1
                ) ) . filename as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_class_entry__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( filename ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const _zend_class_entry__bindgen_ty_1__bindgen_ty_1
                ) ) . line_start as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_class_entry__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( line_start ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const _zend_class_entry__bindgen_ty_1__bindgen_ty_1
                ) ) . line_end as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_class_entry__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( line_end ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const _zend_class_entry__bindgen_ty_1__bindgen_ty_1
                ) ) . doc_comment as * const _ as usize } , 16usize , concat !
                (
                "Alignment of field: " , stringify ! (
                _zend_class_entry__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( doc_comment ) ));
}
impl Clone for _zend_class_entry__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for _zend_class_entry__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _zend_class_entry__bindgen_ty_1__bindgen_ty_2 {
    pub builtin_functions: *const _zend_function_entry,
    pub module: *mut _zend_module_entry,
}
#[test]
fn bindgen_test_layout__zend_class_entry__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<_zend_class_entry__bindgen_ty_1__bindgen_ty_2>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               _zend_class_entry__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<_zend_class_entry__bindgen_ty_1__bindgen_ty_2>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                _zend_class_entry__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const _zend_class_entry__bindgen_ty_1__bindgen_ty_2
                ) ) . builtin_functions as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                _zend_class_entry__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( builtin_functions ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const _zend_class_entry__bindgen_ty_1__bindgen_ty_2
                ) ) . module as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_class_entry__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( module ) ));
}
impl Clone for _zend_class_entry__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for _zend_class_entry__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout__zend_class_entry__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_zend_class_entry__bindgen_ty_1>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( _zend_class_entry__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<_zend_class_entry__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                _zend_class_entry__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry__bindgen_ty_1 ) ) .
                user as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_class_entry__bindgen_ty_1 ) , "::" , stringify ! ( user
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry__bindgen_ty_1 ) ) .
                internal as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_class_entry__bindgen_ty_1 ) , "::" , stringify ! (
                internal ) ));
}
impl Clone for _zend_class_entry__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__zend_class_entry() {
    assert_eq!(::std::mem::size_of::<_zend_class_entry>() , 504usize , concat
               ! ( "Size of: " , stringify ! ( _zend_class_entry ) ));
    assert_eq! (::std::mem::align_of::<_zend_class_entry>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _zend_class_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . name as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . parent as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . refcount as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( refcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . ce_flags as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( ce_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) .
                default_properties_count as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( default_properties_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) .
                default_static_members_count as * const _ as usize } , 36usize
                , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( default_static_members_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) .
                default_properties_table as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( default_properties_table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) .
                default_static_members_table as * const _ as usize } , 48usize
                , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( default_static_members_table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) .
                static_members_table as * const _ as usize } , 56usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( static_members_table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . function_table as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( function_table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . properties_info
                as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( properties_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . constants_table
                as * const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( constants_table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . constructor as *
                const _ as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( constructor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . destructor as *
                const _ as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( destructor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . clone as * const
                _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( clone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . __get as * const
                _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( __get ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . __set as * const
                _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( __set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . __unset as *
                const _ as usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( __unset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . __isset as *
                const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( __isset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . __call as * const
                _ as usize } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( __call ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . __callstatic as *
                const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( __callstatic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . __tostring as *
                const _ as usize } , 304usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( __tostring ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . __debugInfo as *
                const _ as usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( __debugInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . serialize_func as
                * const _ as usize } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( serialize_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . unserialize_func
                as * const _ as usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( unserialize_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . iterator_funcs as
                * const _ as usize } , 336usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( iterator_funcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . create_object as
                * const _ as usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( create_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . get_iterator as *
                const _ as usize } , 400usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( get_iterator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) .
                interface_gets_implemented as * const _ as usize } , 408usize
                , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( interface_gets_implemented ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . get_static_method
                as * const _ as usize } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( get_static_method ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . serialize as *
                const _ as usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( serialize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . unserialize as *
                const _ as usize } , 432usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( unserialize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . num_interfaces as
                * const _ as usize } , 440usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( num_interfaces ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . num_traits as *
                const _ as usize } , 444usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( num_traits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . interfaces as *
                const _ as usize } , 448usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( interfaces ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . traits as * const
                _ as usize } , 456usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( traits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . trait_aliases as
                * const _ as usize } , 464usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( trait_aliases ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . trait_precedences
                as * const _ as usize } , 472usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( trait_precedences ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_entry ) ) . info as * const _
                as usize } , 480usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_class_entry ) ,
                "::" , stringify ! ( info ) ));
}
impl Clone for _zend_class_entry {
    fn clone(&self) -> Self { *self }
}
impl Default for _zend_class_entry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type zend_class_entry = _zend_class_entry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _zend_function {
    _unused: [u8; 0],
}
pub type zend_function = _zend_function;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _zend_execute_data {
    _unused: [u8; 0],
}
pub type zend_execute_data = _zend_execute_data;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _zval_struct {
    pub value: zend_value,
    pub u1: _zval_struct__bindgen_ty_1,
    pub u2: _zval_struct__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _zval_struct__bindgen_ty_1 {
    pub v: __BindgenUnionField<_zval_struct__bindgen_ty_1__bindgen_ty_1>,
    pub type_info: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _zval_struct__bindgen_ty_1__bindgen_ty_1 {
    pub type_: zend_uchar,
    pub type_flags: zend_uchar,
    pub const_flags: zend_uchar,
    pub reserved: zend_uchar,
}
#[test]
fn bindgen_test_layout__zval_struct__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_zval_struct__bindgen_ty_1__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               _zval_struct__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<_zval_struct__bindgen_ty_1__bindgen_ty_1>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                _zval_struct__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const _zval_struct__bindgen_ty_1__bindgen_ty_1 ) )
                . type_ as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zval_struct__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify
                ! ( type_ ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const _zval_struct__bindgen_ty_1__bindgen_ty_1 ) )
                . type_flags as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zval_struct__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify
                ! ( type_flags ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const _zval_struct__bindgen_ty_1__bindgen_ty_1 ) )
                . const_flags as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zval_struct__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify
                ! ( const_flags ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const _zval_struct__bindgen_ty_1__bindgen_ty_1 ) )
                . reserved as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zval_struct__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify
                ! ( reserved ) ));
}
impl Clone for _zval_struct__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__zval_struct__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_zval_struct__bindgen_ty_1>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( _zval_struct__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<_zval_struct__bindgen_ty_1>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( _zval_struct__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zval_struct__bindgen_ty_1 ) ) . v as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zval_struct__bindgen_ty_1 ) , "::" , stringify ! ( v ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zval_struct__bindgen_ty_1 ) ) .
                type_info as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zval_struct__bindgen_ty_1 ) , "::" , stringify ! ( type_info
                ) ));
}
impl Clone for _zval_struct__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _zval_struct__bindgen_ty_2 {
    pub var_flags: __BindgenUnionField<u32>,
    pub next: __BindgenUnionField<u32>,
    pub cache_slot: __BindgenUnionField<u32>,
    pub lineno: __BindgenUnionField<u32>,
    pub num_args: __BindgenUnionField<u32>,
    pub fe_pos: __BindgenUnionField<u32>,
    pub fe_iter_idx: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout__zval_struct__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<_zval_struct__bindgen_ty_2>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( _zval_struct__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<_zval_struct__bindgen_ty_2>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( _zval_struct__bindgen_ty_2 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zval_struct__bindgen_ty_2 ) ) .
                var_flags as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zval_struct__bindgen_ty_2 ) , "::" , stringify ! ( var_flags
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zval_struct__bindgen_ty_2 ) ) . next as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zval_struct__bindgen_ty_2 ) , "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zval_struct__bindgen_ty_2 ) ) .
                cache_slot as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zval_struct__bindgen_ty_2 ) , "::" , stringify ! ( cache_slot
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zval_struct__bindgen_ty_2 ) ) . lineno
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zval_struct__bindgen_ty_2 ) , "::" , stringify ! ( lineno )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zval_struct__bindgen_ty_2 ) ) . num_args
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zval_struct__bindgen_ty_2 ) , "::" , stringify ! ( num_args )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zval_struct__bindgen_ty_2 ) ) . fe_pos
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zval_struct__bindgen_ty_2 ) , "::" , stringify ! ( fe_pos )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zval_struct__bindgen_ty_2 ) ) .
                fe_iter_idx as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zval_struct__bindgen_ty_2 ) , "::" , stringify ! (
                fe_iter_idx ) ));
}
impl Clone for _zval_struct__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__zval_struct() {
    assert_eq!(::std::mem::size_of::<_zval_struct>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _zval_struct ) ));
    assert_eq! (::std::mem::align_of::<_zval_struct>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _zval_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zval_struct ) ) . value as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zval_struct ) , "::" ,
                stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zval_struct ) ) . u1 as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _zval_struct ) , "::" ,
                stringify ! ( u1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zval_struct ) ) . u2 as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _zval_struct ) , "::" ,
                stringify ! ( u2 ) ));
}
impl Clone for _zval_struct {
    fn clone(&self) -> Self { *self }
}
pub type zval = _zval_struct;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _zend_refcounted {
    pub gc: zend_refcounted_h,
}
#[test]
fn bindgen_test_layout__zend_refcounted() {
    assert_eq!(::std::mem::size_of::<_zend_refcounted>() , 8usize , concat ! (
               "Size of: " , stringify ! ( _zend_refcounted ) ));
    assert_eq! (::std::mem::align_of::<_zend_refcounted>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( _zend_refcounted ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_refcounted ) ) . gc as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_refcounted ) ,
                "::" , stringify ! ( gc ) ));
}
impl Clone for _zend_refcounted {
    fn clone(&self) -> Self { *self }
}
pub type zend_refcounted = _zend_refcounted;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _zend_string {
    pub gc: zend_refcounted_h,
    pub h: zend_ulong,
    pub len: usize,
    pub val: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout__zend_string() {
    assert_eq!(::std::mem::size_of::<_zend_string>() , 32usize , concat ! (
               "Size of: " , stringify ! ( _zend_string ) ));
    assert_eq! (::std::mem::align_of::<_zend_string>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _zend_string ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_string ) ) . gc as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_string ) , "::" ,
                stringify ! ( gc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_string ) ) . h as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_string ) , "::" ,
                stringify ! ( h ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_string ) ) . len as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_string ) , "::" ,
                stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_string ) ) . val as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_string ) , "::" ,
                stringify ! ( val ) ));
}
impl Clone for _zend_string {
    fn clone(&self) -> Self { *self }
}
pub type zend_string = _zend_string;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _zend_array {
    pub gc: zend_refcounted_h,
    pub u: _zend_array__bindgen_ty_1,
    pub nTableMask: u32,
    pub arData: *mut Bucket,
    pub nNumUsed: u32,
    pub nNumOfElements: u32,
    pub nTableSize: u32,
    pub nInternalPointer: u32,
    pub nNextFreeElement: zend_long,
    pub pDestructor: dtor_func_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _zend_array__bindgen_ty_1 {
    pub v: __BindgenUnionField<_zend_array__bindgen_ty_1__bindgen_ty_1>,
    pub flags: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _zend_array__bindgen_ty_1__bindgen_ty_1 {
    pub flags: zend_uchar,
    pub nApplyCount: zend_uchar,
    pub nIteratorsCount: zend_uchar,
    pub reserve: zend_uchar,
}
#[test]
fn bindgen_test_layout__zend_array__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_zend_array__bindgen_ty_1__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               _zend_array__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<_zend_array__bindgen_ty_1__bindgen_ty_1>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                _zend_array__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_array__bindgen_ty_1__bindgen_ty_1 )
                ) . flags as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_array__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify !
                ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_array__bindgen_ty_1__bindgen_ty_1 )
                ) . nApplyCount as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_array__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify !
                ( nApplyCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_array__bindgen_ty_1__bindgen_ty_1 )
                ) . nIteratorsCount as * const _ as usize } , 2usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                _zend_array__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify !
                ( nIteratorsCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_array__bindgen_ty_1__bindgen_ty_1 )
                ) . reserve as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_array__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify !
                ( reserve ) ));
}
impl Clone for _zend_array__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__zend_array__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_zend_array__bindgen_ty_1>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( _zend_array__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<_zend_array__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( _zend_array__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_array__bindgen_ty_1 ) ) . v as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_array__bindgen_ty_1 ) , "::" , stringify ! ( v ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_array__bindgen_ty_1 ) ) . flags as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_array__bindgen_ty_1 ) , "::" , stringify ! ( flags ) ));
}
impl Clone for _zend_array__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__zend_array() {
    assert_eq!(::std::mem::size_of::<_zend_array>() , 56usize , concat ! (
               "Size of: " , stringify ! ( _zend_array ) ));
    assert_eq! (::std::mem::align_of::<_zend_array>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _zend_array ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_array ) ) . gc as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_array ) , "::" ,
                stringify ! ( gc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_array ) ) . u as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_array ) , "::" ,
                stringify ! ( u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_array ) ) . nTableMask as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_array ) , "::" ,
                stringify ! ( nTableMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_array ) ) . arData as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_array ) , "::" ,
                stringify ! ( arData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_array ) ) . nNumUsed as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_array ) , "::" ,
                stringify ! ( nNumUsed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_array ) ) . nNumOfElements as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_array ) , "::" ,
                stringify ! ( nNumOfElements ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_array ) ) . nTableSize as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_array ) , "::" ,
                stringify ! ( nTableSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_array ) ) . nInternalPointer as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_array ) , "::" ,
                stringify ! ( nInternalPointer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_array ) ) . nNextFreeElement as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_array ) , "::" ,
                stringify ! ( nNextFreeElement ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_array ) ) . pDestructor as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_array ) , "::" ,
                stringify ! ( pDestructor ) ));
}
impl Clone for _zend_array {
    fn clone(&self) -> Self { *self }
}
impl Default for _zend_array {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type zend_array = _zend_array;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _zend_object {
    pub gc: zend_refcounted_h,
    pub handle: u32,
    pub ce: *mut zend_class_entry,
    pub handlers: *const zend_object_handlers,
    pub properties: *mut HashTable,
    pub properties_table: [zval; 1usize],
}
#[test]
fn bindgen_test_layout__zend_object() {
    assert_eq!(::std::mem::size_of::<_zend_object>() , 56usize , concat ! (
               "Size of: " , stringify ! ( _zend_object ) ));
    assert_eq! (::std::mem::align_of::<_zend_object>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _zend_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object ) ) . gc as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object ) , "::" ,
                stringify ! ( gc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object ) ) . handle as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object ) , "::" ,
                stringify ! ( handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object ) ) . ce as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object ) , "::" ,
                stringify ! ( ce ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object ) ) . handlers as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object ) , "::" ,
                stringify ! ( handlers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object ) ) . properties as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object ) , "::" ,
                stringify ! ( properties ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object ) ) . properties_table as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object ) , "::" ,
                stringify ! ( properties_table ) ));
}
impl Clone for _zend_object {
    fn clone(&self) -> Self { *self }
}
impl Default for _zend_object {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type zend_object = _zend_object;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _zend_resource {
    pub gc: zend_refcounted_h,
    pub handle: ::std::os::raw::c_int,
    pub type_: ::std::os::raw::c_int,
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__zend_resource() {
    assert_eq!(::std::mem::size_of::<_zend_resource>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _zend_resource ) ));
    assert_eq! (::std::mem::align_of::<_zend_resource>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _zend_resource ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_resource ) ) . gc as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_resource ) , "::"
                , stringify ! ( gc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_resource ) ) . handle as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_resource ) , "::"
                , stringify ! ( handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_resource ) ) . type_ as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_resource ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_resource ) ) . ptr as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_resource ) , "::"
                , stringify ! ( ptr ) ));
}
impl Clone for _zend_resource {
    fn clone(&self) -> Self { *self }
}
impl Default for _zend_resource {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type zend_resource = _zend_resource;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _zend_reference {
    pub gc: zend_refcounted_h,
    pub val: zval,
}
#[test]
fn bindgen_test_layout__zend_reference() {
    assert_eq!(::std::mem::size_of::<_zend_reference>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _zend_reference ) ));
    assert_eq! (::std::mem::align_of::<_zend_reference>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _zend_reference ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_reference ) ) . gc as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_reference ) ,
                "::" , stringify ! ( gc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_reference ) ) . val as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_reference ) ,
                "::" , stringify ! ( val ) ));
}
impl Clone for _zend_reference {
    fn clone(&self) -> Self { *self }
}
pub type zend_reference = _zend_reference;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _zend_ast_ref {
    pub gc: zend_refcounted_h,
    pub ast: *mut zend_ast,
}
#[test]
fn bindgen_test_layout__zend_ast_ref() {
    assert_eq!(::std::mem::size_of::<_zend_ast_ref>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _zend_ast_ref ) ));
    assert_eq! (::std::mem::align_of::<_zend_ast_ref>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _zend_ast_ref ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_ast_ref ) ) . gc as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_ast_ref ) , "::"
                , stringify ! ( gc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_ast_ref ) ) . ast as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_ast_ref ) , "::"
                , stringify ! ( ast ) ));
}
impl Clone for _zend_ast_ref {
    fn clone(&self) -> Self { *self }
}
impl Default for _zend_ast_ref {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type zend_ast_ref = _zend_ast_ref;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _zend_ast {
    pub kind: zend_ast_kind,
    pub attr: zend_ast_attr,
    pub lineno: u32,
    pub child: [*mut zend_ast; 1usize],
}
#[test]
fn bindgen_test_layout__zend_ast() {
    assert_eq!(::std::mem::size_of::<_zend_ast>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _zend_ast ) ));
    assert_eq! (::std::mem::align_of::<_zend_ast>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _zend_ast ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_ast ) ) . kind as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_ast ) , "::" ,
                stringify ! ( kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_ast ) ) . attr as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_ast ) , "::" ,
                stringify ! ( attr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_ast ) ) . lineno as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_ast ) , "::" ,
                stringify ! ( lineno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_ast ) ) . child as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_ast ) , "::" ,
                stringify ! ( child ) ));
}
impl Clone for _zend_ast {
    fn clone(&self) -> Self { *self }
}
impl Default for _zend_ast {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type zend_ast = _zend_ast;
pub type compare_func_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void,
                                               arg2:
                                                   *const ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type swap_func_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2:
                                                   *mut ::std::os::raw::c_void)>;
pub type sort_func_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: usize, arg3: usize,
                                               arg4: compare_func_t,
                                               arg5: swap_func_t)>;
pub type dtor_func_t =
    ::std::option::Option<unsafe extern "C" fn(pDest: *mut zval)>;
pub type copy_ctor_func_t =
    ::std::option::Option<unsafe extern "C" fn(pElement: *mut zval)>;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _zend_value {
    pub lval: __BindgenUnionField<zend_long>,
    pub dval: __BindgenUnionField<f64>,
    pub counted: __BindgenUnionField<*mut zend_refcounted>,
    pub str: __BindgenUnionField<*mut zend_string>,
    pub arr: __BindgenUnionField<*mut zend_array>,
    pub obj: __BindgenUnionField<*mut zend_object>,
    pub res: __BindgenUnionField<*mut zend_resource>,
    pub ref_: __BindgenUnionField<*mut zend_reference>,
    pub ast: __BindgenUnionField<*mut zend_ast_ref>,
    pub zv: __BindgenUnionField<*mut zval>,
    pub ptr: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub ce: __BindgenUnionField<*mut zend_class_entry>,
    pub func: __BindgenUnionField<*mut zend_function>,
    pub ww: __BindgenUnionField<_zend_value__bindgen_ty_1>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _zend_value__bindgen_ty_1 {
    pub w1: u32,
    pub w2: u32,
}
#[test]
fn bindgen_test_layout__zend_value__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_zend_value__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( _zend_value__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<_zend_value__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( _zend_value__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_value__bindgen_ty_1 ) ) . w1 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_value__bindgen_ty_1 ) , "::" , stringify ! ( w1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_value__bindgen_ty_1 ) ) . w2 as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_value__bindgen_ty_1 ) , "::" , stringify ! ( w2 ) ));
}
impl Clone for _zend_value__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__zend_value() {
    assert_eq!(::std::mem::size_of::<_zend_value>() , 8usize , concat ! (
               "Size of: " , stringify ! ( _zend_value ) ));
    assert_eq! (::std::mem::align_of::<_zend_value>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _zend_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_value ) ) . lval as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_value ) , "::" ,
                stringify ! ( lval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_value ) ) . dval as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_value ) , "::" ,
                stringify ! ( dval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_value ) ) . counted as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_value ) , "::" ,
                stringify ! ( counted ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_value ) ) . str as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_value ) , "::" ,
                stringify ! ( str ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_value ) ) . arr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_value ) , "::" ,
                stringify ! ( arr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_value ) ) . obj as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_value ) , "::" ,
                stringify ! ( obj ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_value ) ) . res as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_value ) , "::" ,
                stringify ! ( res ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_value ) ) . ref_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_value ) , "::" ,
                stringify ! ( ref_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_value ) ) . ast as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_value ) , "::" ,
                stringify ! ( ast ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_value ) ) . zv as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_value ) , "::" ,
                stringify ! ( zv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_value ) ) . ptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_value ) , "::" ,
                stringify ! ( ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_value ) ) . ce as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_value ) , "::" ,
                stringify ! ( ce ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_value ) ) . func as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_value ) , "::" ,
                stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_value ) ) . ww as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_value ) , "::" ,
                stringify ! ( ww ) ));
}
impl Clone for _zend_value {
    fn clone(&self) -> Self { *self }
}
pub type zend_value = _zend_value;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _zend_refcounted_h {
    pub refcount: u32,
    pub u: _zend_refcounted_h__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _zend_refcounted_h__bindgen_ty_1 {
    pub v: __BindgenUnionField<_zend_refcounted_h__bindgen_ty_1__bindgen_ty_1>,
    pub type_info: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _zend_refcounted_h__bindgen_ty_1__bindgen_ty_1 {
    pub type_: zend_uchar,
    pub flags: zend_uchar,
    pub gc_info: u16,
}
#[test]
fn bindgen_test_layout__zend_refcounted_h__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_zend_refcounted_h__bindgen_ty_1__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               _zend_refcounted_h__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<_zend_refcounted_h__bindgen_ty_1__bindgen_ty_1>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                _zend_refcounted_h__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const _zend_refcounted_h__bindgen_ty_1__bindgen_ty_1 )
                ) . type_ as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_refcounted_h__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const _zend_refcounted_h__bindgen_ty_1__bindgen_ty_1 )
                ) . flags as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_refcounted_h__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const _zend_refcounted_h__bindgen_ty_1__bindgen_ty_1 )
                ) . gc_info as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_refcounted_h__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( gc_info ) ));
}
impl Clone for _zend_refcounted_h__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__zend_refcounted_h__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_zend_refcounted_h__bindgen_ty_1>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( _zend_refcounted_h__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<_zend_refcounted_h__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                _zend_refcounted_h__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_refcounted_h__bindgen_ty_1 ) ) . v
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_refcounted_h__bindgen_ty_1 ) , "::" , stringify ! ( v )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_refcounted_h__bindgen_ty_1 ) ) .
                type_info as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_refcounted_h__bindgen_ty_1 ) , "::" , stringify ! (
                type_info ) ));
}
impl Clone for _zend_refcounted_h__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__zend_refcounted_h() {
    assert_eq!(::std::mem::size_of::<_zend_refcounted_h>() , 8usize , concat !
               ( "Size of: " , stringify ! ( _zend_refcounted_h ) ));
    assert_eq! (::std::mem::align_of::<_zend_refcounted_h>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( _zend_refcounted_h ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_refcounted_h ) ) . refcount as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_refcounted_h ) ,
                "::" , stringify ! ( refcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_refcounted_h ) ) . u as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_refcounted_h ) ,
                "::" , stringify ! ( u ) ));
}
impl Clone for _zend_refcounted_h {
    fn clone(&self) -> Self { *self }
}
pub type zend_refcounted_h = _zend_refcounted_h;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _Bucket {
    pub val: zval,
    pub h: zend_ulong,
    pub key: *mut zend_string,
}
#[test]
fn bindgen_test_layout__Bucket() {
    assert_eq!(::std::mem::size_of::<_Bucket>() , 32usize , concat ! (
               "Size of: " , stringify ! ( _Bucket ) ));
    assert_eq! (::std::mem::align_of::<_Bucket>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _Bucket ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _Bucket ) ) . val as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _Bucket ) , "::" ,
                stringify ! ( val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _Bucket ) ) . h as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! ( _Bucket ) , "::" ,
                stringify ! ( h ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _Bucket ) ) . key as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _Bucket ) , "::" ,
                stringify ! ( key ) ));
}
impl Clone for _Bucket {
    fn clone(&self) -> Self { *self }
}
impl Default for _Bucket {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Bucket = _Bucket;
pub type HashTable = _zend_array;
pub type HashPosition = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _HashTableIterator {
    pub ht: *mut HashTable,
    pub pos: HashPosition,
}
#[test]
fn bindgen_test_layout__HashTableIterator() {
    assert_eq!(::std::mem::size_of::<_HashTableIterator>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( _HashTableIterator ) ));
    assert_eq! (::std::mem::align_of::<_HashTableIterator>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _HashTableIterator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _HashTableIterator ) ) . ht as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _HashTableIterator ) ,
                "::" , stringify ! ( ht ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _HashTableIterator ) ) . pos as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _HashTableIterator ) ,
                "::" , stringify ! ( pos ) ));
}
impl Clone for _HashTableIterator {
    fn clone(&self) -> Self { *self }
}
impl Default for _HashTableIterator {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type HashTableIterator = _HashTableIterator;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _zend_leak_info {
    pub addr: *mut ::std::os::raw::c_void,
    pub size: usize,
    pub filename: *const ::std::os::raw::c_char,
    pub orig_filename: *const ::std::os::raw::c_char,
    pub lineno: uint,
    pub orig_lineno: uint,
}
#[test]
fn bindgen_test_layout__zend_leak_info() {
    assert_eq!(::std::mem::size_of::<_zend_leak_info>() , 40usize , concat ! (
               "Size of: " , stringify ! ( _zend_leak_info ) ));
    assert_eq! (::std::mem::align_of::<_zend_leak_info>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _zend_leak_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_leak_info ) ) . addr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_leak_info ) ,
                "::" , stringify ! ( addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_leak_info ) ) . size as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_leak_info ) ,
                "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_leak_info ) ) . filename as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_leak_info ) ,
                "::" , stringify ! ( filename ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_leak_info ) ) . orig_filename as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_leak_info ) ,
                "::" , stringify ! ( orig_filename ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_leak_info ) ) . lineno as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_leak_info ) ,
                "::" , stringify ! ( lineno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_leak_info ) ) . orig_lineno as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_leak_info ) ,
                "::" , stringify ! ( orig_lineno ) ));
}
impl Clone for _zend_leak_info {
    fn clone(&self) -> Self { *self }
}
impl Default for _zend_leak_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type zend_leak_info = _zend_leak_info;
extern "C" {
    pub fn zend_strndup(s: *const ::std::os::raw::c_char, length: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _emalloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _safe_emalloc(nmemb: usize, size: usize, offset: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _safe_malloc(nmemb: usize, size: usize, offset: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _efree(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _ecalloc(nmemb: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _erealloc(ptr: *mut ::std::os::raw::c_void, size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _erealloc2(ptr: *mut ::std::os::raw::c_void, size: usize,
                      copy_size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _safe_erealloc(ptr: *mut ::std::os::raw::c_void, nmemb: usize,
                          size: usize, offset: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _safe_realloc(ptr: *mut ::std::os::raw::c_void, nmemb: usize,
                         size: usize, offset: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _estrdup(s: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _estrndup(s: *const ::std::os::raw::c_char, length: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _zend_mem_block_size(ptr: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _emalloc_8() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_16() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_24() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_32() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_40() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_48() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_56() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_64() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_80() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_96() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_112() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_128() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_160() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_192() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_224() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_256() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_320() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_384() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_448() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_512() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_640() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_768() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_896() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_1024() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_1280() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_1536() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_1792() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_2048() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_2560() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_3072() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_large(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _emalloc_huge(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _efree_8(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_16(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_24(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_32(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_40(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_48(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_56(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_64(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_80(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_96(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_112(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_128(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_160(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_192(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_224(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_256(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_320(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_384(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_448(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_512(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_640(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_768(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_896(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_1024(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_1280(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_1536(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_1792(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_2048(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_2560(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_3072(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _efree_large(arg1: *mut ::std::os::raw::c_void, size: usize);
}
extern "C" {
    pub fn _efree_huge(arg1: *mut ::std::os::raw::c_void, size: usize);
}
extern "C" {
    pub fn __zend_malloc(len: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __zend_calloc(nmemb: usize, len: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __zend_realloc(p: *mut ::std::os::raw::c_void, len: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn zend_set_memory_limit(memory_limit: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn start_memory_manager();
}
extern "C" {
    pub fn shutdown_memory_manager(silent: ::std::os::raw::c_int,
                                   full_shutdown: ::std::os::raw::c_int);
}
extern "C" {
    pub fn is_zend_mm() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_memory_usage(real_usage: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    pub fn zend_memory_peak_usage(real_usage: ::std::os::raw::c_int) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _zend_mm_heap {
    _unused: [u8; 0],
}
pub type zend_mm_heap = _zend_mm_heap;
extern "C" {
    pub fn zend_mm_startup() -> *mut zend_mm_heap;
}
extern "C" {
    pub fn zend_mm_shutdown(heap: *mut zend_mm_heap,
                            full_shutdown: ::std::os::raw::c_int,
                            silent: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _zend_mm_alloc(heap: *mut zend_mm_heap, size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _zend_mm_free(heap: *mut zend_mm_heap,
                         p: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _zend_mm_realloc(heap: *mut zend_mm_heap,
                            p: *mut ::std::os::raw::c_void, size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _zend_mm_realloc2(heap: *mut zend_mm_heap,
                             p: *mut ::std::os::raw::c_void, size: usize,
                             copy_size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _zend_mm_block_size(heap: *mut zend_mm_heap,
                               p: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn zend_mm_set_heap(new_heap: *mut zend_mm_heap) -> *mut zend_mm_heap;
}
extern "C" {
    pub fn zend_mm_get_heap() -> *mut zend_mm_heap;
}
extern "C" {
    pub fn zend_mm_gc(heap: *mut zend_mm_heap) -> usize;
}
extern "C" {
    pub fn zend_mm_is_custom_heap(new_heap: *mut zend_mm_heap)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_mm_set_custom_handlers(heap: *mut zend_mm_heap,
                                       _malloc:
                                           ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                          usize)
                                                                     ->
                                                                         *mut ::std::os::raw::c_void>,
                                       _free:
                                           ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                          *mut ::std::os::raw::c_void)>,
                                       _realloc:
                                           ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                          *mut ::std::os::raw::c_void,
                                                                                      arg2:
                                                                                          usize)
                                                                     ->
                                                                         *mut ::std::os::raw::c_void>);
}
extern "C" {
    pub fn zend_mm_get_custom_handlers(heap: *mut zend_mm_heap,
                                       _malloc:
                                           *mut ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                               usize)
                                                                          ->
                                                                              *mut ::std::os::raw::c_void>,
                                       _free:
                                           *mut ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                               *mut ::std::os::raw::c_void)>,
                                       _realloc:
                                           *mut ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                               *mut ::std::os::raw::c_void,
                                                                                           arg2:
                                                                                               usize)
                                                                          ->
                                                                              *mut ::std::os::raw::c_void>);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _zend_mm_storage {
    pub handlers: zend_mm_handlers,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__zend_mm_storage() {
    assert_eq!(::std::mem::size_of::<_zend_mm_storage>() , 40usize , concat !
               ( "Size of: " , stringify ! ( _zend_mm_storage ) ));
    assert_eq! (::std::mem::align_of::<_zend_mm_storage>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _zend_mm_storage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_mm_storage ) ) . handlers as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_mm_storage ) ,
                "::" , stringify ! ( handlers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_mm_storage ) ) . data as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_mm_storage ) ,
                "::" , stringify ! ( data ) ));
}
impl Clone for _zend_mm_storage {
    fn clone(&self) -> Self { *self }
}
impl Default for _zend_mm_storage {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type zend_mm_storage = _zend_mm_storage;
pub type zend_mm_chunk_alloc_t =
    ::std::option::Option<unsafe extern "C" fn(storage: *mut zend_mm_storage,
                                               size: usize, alignment: usize)
                              -> *mut ::std::os::raw::c_void>;
pub type zend_mm_chunk_free_t =
    ::std::option::Option<unsafe extern "C" fn(storage: *mut zend_mm_storage,
                                               chunk:
                                                   *mut ::std::os::raw::c_void,
                                               size: usize)>;
pub type zend_mm_chunk_truncate_t =
    ::std::option::Option<unsafe extern "C" fn(storage: *mut zend_mm_storage,
                                               chunk:
                                                   *mut ::std::os::raw::c_void,
                                               old_size: usize,
                                               new_size: usize)
                              -> ::std::os::raw::c_int>;
pub type zend_mm_chunk_extend_t =
    ::std::option::Option<unsafe extern "C" fn(storage: *mut zend_mm_storage,
                                               chunk:
                                                   *mut ::std::os::raw::c_void,
                                               old_size: usize,
                                               new_size: usize)
                              -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _zend_mm_handlers {
    pub chunk_alloc: zend_mm_chunk_alloc_t,
    pub chunk_free: zend_mm_chunk_free_t,
    pub chunk_truncate: zend_mm_chunk_truncate_t,
    pub chunk_extend: zend_mm_chunk_extend_t,
}
#[test]
fn bindgen_test_layout__zend_mm_handlers() {
    assert_eq!(::std::mem::size_of::<_zend_mm_handlers>() , 32usize , concat !
               ( "Size of: " , stringify ! ( _zend_mm_handlers ) ));
    assert_eq! (::std::mem::align_of::<_zend_mm_handlers>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _zend_mm_handlers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_mm_handlers ) ) . chunk_alloc as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_mm_handlers ) ,
                "::" , stringify ! ( chunk_alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_mm_handlers ) ) . chunk_free as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_mm_handlers ) ,
                "::" , stringify ! ( chunk_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_mm_handlers ) ) . chunk_truncate as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_mm_handlers ) ,
                "::" , stringify ! ( chunk_truncate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_mm_handlers ) ) . chunk_extend as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_mm_handlers ) ,
                "::" , stringify ! ( chunk_extend ) ));
}
impl Clone for _zend_mm_handlers {
    fn clone(&self) -> Self { *self }
}
impl Default for _zend_mm_handlers {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type zend_mm_handlers = _zend_mm_handlers;
extern "C" {
    pub fn zend_mm_get_storage(heap: *mut zend_mm_heap)
     -> *mut zend_mm_storage;
}
extern "C" {
    pub fn zend_mm_startup_ex(handlers: *const zend_mm_handlers,
                              data: *mut ::std::os::raw::c_void,
                              data_size: usize) -> *mut zend_mm_heap;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _zend_llist_element {
    pub next: *mut _zend_llist_element,
    pub prev: *mut _zend_llist_element,
    pub data: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout__zend_llist_element() {
    assert_eq!(::std::mem::size_of::<_zend_llist_element>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( _zend_llist_element ) ));
    assert_eq! (::std::mem::align_of::<_zend_llist_element>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _zend_llist_element ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_llist_element ) ) . next as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_llist_element ) ,
                "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_llist_element ) ) . prev as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_llist_element ) ,
                "::" , stringify ! ( prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_llist_element ) ) . data as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_llist_element ) ,
                "::" , stringify ! ( data ) ));
}
impl Clone for _zend_llist_element {
    fn clone(&self) -> Self { *self }
}
impl Default for _zend_llist_element {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type zend_llist_element = _zend_llist_element;
pub type llist_dtor_func_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void)>;
pub type llist_compare_func_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut *const zend_llist_element,
                                               arg2:
                                                   *mut *const zend_llist_element)
                              -> ::std::os::raw::c_int>;
pub type llist_apply_with_args_func_t =
    ::std::option::Option<unsafe extern "C" fn(data:
                                                   *mut ::std::os::raw::c_void,
                                               num_args:
                                                   ::std::os::raw::c_int,
                                               args: *mut __va_list_tag)>;
pub type llist_apply_with_arg_func_t =
    ::std::option::Option<unsafe extern "C" fn(data:
                                                   *mut ::std::os::raw::c_void,
                                               arg:
                                                   *mut ::std::os::raw::c_void)>;
pub type llist_apply_func_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _zend_llist {
    pub head: *mut zend_llist_element,
    pub tail: *mut zend_llist_element,
    pub count: usize,
    pub size: usize,
    pub dtor: llist_dtor_func_t,
    pub persistent: ::std::os::raw::c_uchar,
    pub traverse_ptr: *mut zend_llist_element,
}
#[test]
fn bindgen_test_layout__zend_llist() {
    assert_eq!(::std::mem::size_of::<_zend_llist>() , 56usize , concat ! (
               "Size of: " , stringify ! ( _zend_llist ) ));
    assert_eq! (::std::mem::align_of::<_zend_llist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _zend_llist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_llist ) ) . head as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_llist ) , "::" ,
                stringify ! ( head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_llist ) ) . tail as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_llist ) , "::" ,
                stringify ! ( tail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_llist ) ) . count as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_llist ) , "::" ,
                stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_llist ) ) . size as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_llist ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_llist ) ) . dtor as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_llist ) , "::" ,
                stringify ! ( dtor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_llist ) ) . persistent as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_llist ) , "::" ,
                stringify ! ( persistent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_llist ) ) . traverse_ptr as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_llist ) , "::" ,
                stringify ! ( traverse_ptr ) ));
}
impl Clone for _zend_llist {
    fn clone(&self) -> Self { *self }
}
impl Default for _zend_llist {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type zend_llist = _zend_llist;
pub type zend_llist_position = *mut zend_llist_element;
extern "C" {
    pub fn zend_llist_init(l: *mut zend_llist, size: usize,
                           dtor: llist_dtor_func_t,
                           persistent: ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn zend_llist_add_element(l: *mut zend_llist,
                                  element: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn zend_llist_prepend_element(l: *mut zend_llist,
                                      element: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn zend_llist_del_element(l: *mut zend_llist,
                                  element: *mut ::std::os::raw::c_void,
                                  compare:
                                      ::std::option::Option<unsafe extern "C" fn(element1:
                                                                                     *mut ::std::os::raw::c_void,
                                                                                 element2:
                                                                                     *mut ::std::os::raw::c_void)
                                                                ->
                                                                    ::std::os::raw::c_int>);
}
extern "C" {
    pub fn zend_llist_destroy(l: *mut zend_llist);
}
extern "C" {
    pub fn zend_llist_clean(l: *mut zend_llist);
}
extern "C" {
    pub fn zend_llist_remove_tail(l: *mut zend_llist);
}
extern "C" {
    pub fn zend_llist_copy(dst: *mut zend_llist, src: *mut zend_llist);
}
extern "C" {
    pub fn zend_llist_apply(l: *mut zend_llist, func: llist_apply_func_t);
}
extern "C" {
    pub fn zend_llist_apply_with_del(l: *mut zend_llist,
                                     func:
                                         ::std::option::Option<unsafe extern "C" fn(data:
                                                                                        *mut ::std::os::raw::c_void)
                                                                   ->
                                                                       ::std::os::raw::c_int>);
}
extern "C" {
    pub fn zend_llist_apply_with_argument(l: *mut zend_llist,
                                          func: llist_apply_with_arg_func_t,
                                          arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn zend_llist_apply_with_arguments(l: *mut zend_llist,
                                           func: llist_apply_with_args_func_t,
                                           num_args:
                                               ::std::os::raw::c_int, ...);
}
extern "C" {
    pub fn zend_llist_count(l: *mut zend_llist) -> usize;
}
extern "C" {
    pub fn zend_llist_sort(l: *mut zend_llist,
                           comp_func: llist_compare_func_t);
}
extern "C" {
    pub fn zend_llist_get_first_ex(l: *mut zend_llist,
                                   pos: *mut zend_llist_position)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn zend_llist_get_last_ex(l: *mut zend_llist,
                                  pos: *mut zend_llist_position)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn zend_llist_get_next_ex(l: *mut zend_llist,
                                  pos: *mut zend_llist_position)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn zend_llist_get_prev_ex(l: *mut zend_llist,
                                  pos: *mut zend_llist_position)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "zend_new_interned_string"]
    pub static mut zend_new_interned_string:
               ::std::option::Option<unsafe extern "C" fn(str:
                                                              *mut zend_string)
                                         -> *mut zend_string>;
}
extern "C" {
    #[link_name = "zend_interned_strings_snapshot"]
    pub static mut zend_interned_strings_snapshot:
               ::std::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    #[link_name = "zend_interned_strings_restore"]
    pub static mut zend_interned_strings_restore:
               ::std::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub fn zend_hash_func(str: *const ::std::os::raw::c_char, len: usize)
     -> zend_ulong;
}
extern "C" {
    pub fn zend_interned_strings_init();
}
extern "C" {
    pub fn zend_interned_strings_dtor();
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _zend_hash_key {
    pub h: zend_ulong,
    pub key: *mut zend_string,
}
#[test]
fn bindgen_test_layout__zend_hash_key() {
    assert_eq!(::std::mem::size_of::<_zend_hash_key>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _zend_hash_key ) ));
    assert_eq! (::std::mem::align_of::<_zend_hash_key>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _zend_hash_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_hash_key ) ) . h as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_hash_key ) , "::"
                , stringify ! ( h ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_hash_key ) ) . key as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_hash_key ) , "::"
                , stringify ! ( key ) ));
}
impl Clone for _zend_hash_key {
    fn clone(&self) -> Self { *self }
}
impl Default for _zend_hash_key {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type zend_hash_key = _zend_hash_key;
pub type merge_checker_func_t =
    ::std::option::Option<unsafe extern "C" fn(target_ht: *mut HashTable,
                                               source_data: *mut zval,
                                               hash_key: *mut zend_hash_key,
                                               pParam:
                                                   *mut ::std::os::raw::c_void)
                              -> zend_bool>;
extern "C" {
    pub fn _zend_hash_init(ht: *mut HashTable, nSize: u32,
                           pDestructor: dtor_func_t, persistent: zend_bool);
}
extern "C" {
    pub fn _zend_hash_init_ex(ht: *mut HashTable, nSize: u32,
                              pDestructor: dtor_func_t, persistent: zend_bool,
                              bApplyProtection: zend_bool);
}
extern "C" {
    pub fn zend_hash_destroy(ht: *mut HashTable);
}
extern "C" {
    pub fn zend_hash_clean(ht: *mut HashTable);
}
extern "C" {
    pub fn zend_hash_real_init(ht: *mut HashTable, packed: zend_bool);
}
extern "C" {
    pub fn zend_hash_packed_to_hash(ht: *mut HashTable);
}
extern "C" {
    pub fn zend_hash_to_packed(ht: *mut HashTable);
}
extern "C" {
    pub fn zend_hash_extend(ht: *mut HashTable, nSize: u32,
                            packed: zend_bool);
}
extern "C" {
    pub fn _zend_hash_add_or_update(ht: *mut HashTable, key: *mut zend_string,
                                    pData: *mut zval, flag: u32) -> *mut zval;
}
extern "C" {
    pub fn _zend_hash_update(ht: *mut HashTable, key: *mut zend_string,
                             pData: *mut zval) -> *mut zval;
}
extern "C" {
    pub fn _zend_hash_update_ind(ht: *mut HashTable, key: *mut zend_string,
                                 pData: *mut zval) -> *mut zval;
}
extern "C" {
    pub fn _zend_hash_add(ht: *mut HashTable, key: *mut zend_string,
                          pData: *mut zval) -> *mut zval;
}
extern "C" {
    pub fn _zend_hash_add_new(ht: *mut HashTable, key: *mut zend_string,
                              pData: *mut zval) -> *mut zval;
}
extern "C" {
    pub fn _zend_hash_str_add_or_update(ht: *mut HashTable,
                                        key: *const ::std::os::raw::c_char,
                                        len: usize, pData: *mut zval,
                                        flag: u32) -> *mut zval;
}
extern "C" {
    pub fn _zend_hash_str_update(ht: *mut HashTable,
                                 key: *const ::std::os::raw::c_char,
                                 len: usize, pData: *mut zval) -> *mut zval;
}
extern "C" {
    pub fn _zend_hash_str_update_ind(ht: *mut HashTable,
                                     key: *const ::std::os::raw::c_char,
                                     len: usize, pData: *mut zval)
     -> *mut zval;
}
extern "C" {
    pub fn _zend_hash_str_add(ht: *mut HashTable,
                              key: *const ::std::os::raw::c_char, len: usize,
                              pData: *mut zval) -> *mut zval;
}
extern "C" {
    pub fn _zend_hash_str_add_new(ht: *mut HashTable,
                                  key: *const ::std::os::raw::c_char,
                                  len: usize, pData: *mut zval) -> *mut zval;
}
extern "C" {
    pub fn _zend_hash_index_add_or_update(ht: *mut HashTable, h: zend_ulong,
                                          pData: *mut zval, flag: u32)
     -> *mut zval;
}
extern "C" {
    pub fn _zend_hash_index_add(ht: *mut HashTable, h: zend_ulong,
                                pData: *mut zval) -> *mut zval;
}
extern "C" {
    pub fn _zend_hash_index_add_new(ht: *mut HashTable, h: zend_ulong,
                                    pData: *mut zval) -> *mut zval;
}
extern "C" {
    pub fn _zend_hash_index_update(ht: *mut HashTable, h: zend_ulong,
                                   pData: *mut zval) -> *mut zval;
}
extern "C" {
    pub fn _zend_hash_next_index_insert(ht: *mut HashTable, pData: *mut zval)
     -> *mut zval;
}
extern "C" {
    pub fn _zend_hash_next_index_insert_new(ht: *mut HashTable,
                                            pData: *mut zval) -> *mut zval;
}
extern "C" {
    pub fn zend_hash_index_add_empty_element(ht: *mut HashTable,
                                             h: zend_ulong) -> *mut zval;
}
extern "C" {
    pub fn zend_hash_add_empty_element(ht: *mut HashTable,
                                       key: *mut zend_string) -> *mut zval;
}
extern "C" {
    pub fn zend_hash_str_add_empty_element(ht: *mut HashTable,
                                           key: *const ::std::os::raw::c_char,
                                           len: usize) -> *mut zval;
}
pub type apply_func_t =
    ::std::option::Option<unsafe extern "C" fn(pDest: *mut zval)
                              -> ::std::os::raw::c_int>;
pub type apply_func_arg_t =
    ::std::option::Option<unsafe extern "C" fn(pDest: *mut zval,
                                               argument:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type apply_func_args_t =
    ::std::option::Option<unsafe extern "C" fn(pDest: *mut zval,
                                               num_args:
                                                   ::std::os::raw::c_int,
                                               args: *mut __va_list_tag,
                                               hash_key: *mut zend_hash_key)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn zend_hash_graceful_destroy(ht: *mut HashTable);
}
extern "C" {
    pub fn zend_hash_graceful_reverse_destroy(ht: *mut HashTable);
}
extern "C" {
    pub fn zend_hash_apply(ht: *mut HashTable, apply_func: apply_func_t);
}
extern "C" {
    pub fn zend_hash_apply_with_argument(ht: *mut HashTable,
                                         apply_func: apply_func_arg_t,
                                         arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn zend_hash_apply_with_arguments(ht: *mut HashTable,
                                          apply_func: apply_func_args_t,
                                          arg1: ::std::os::raw::c_int, ...);
}
extern "C" {
    pub fn zend_hash_reverse_apply(ht: *mut HashTable,
                                   apply_func: apply_func_t);
}
extern "C" {
    pub fn zend_hash_del(ht: *mut HashTable, key: *mut zend_string)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_hash_del_ind(ht: *mut HashTable, key: *mut zend_string)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_hash_str_del(ht: *mut HashTable,
                             key: *const ::std::os::raw::c_char, len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_hash_str_del_ind(ht: *mut HashTable,
                                 key: *const ::std::os::raw::c_char,
                                 len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_hash_index_del(ht: *mut HashTable, h: zend_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_hash_del_bucket(ht: *mut HashTable, p: *mut Bucket);
}
extern "C" {
    pub fn zend_hash_find(ht: *const HashTable, key: *mut zend_string)
     -> *mut zval;
}
extern "C" {
    pub fn zend_hash_str_find(ht: *const HashTable,
                              key: *const ::std::os::raw::c_char, len: usize)
     -> *mut zval;
}
extern "C" {
    pub fn zend_hash_index_find(ht: *const HashTable, h: zend_ulong)
     -> *mut zval;
}
extern "C" {
    pub fn zend_hash_exists(ht: *const HashTable, key: *mut zend_string)
     -> zend_bool;
}
extern "C" {
    pub fn zend_hash_str_exists(ht: *const HashTable,
                                str: *const ::std::os::raw::c_char,
                                len: usize) -> zend_bool;
}
extern "C" {
    pub fn zend_hash_index_exists(ht: *const HashTable, h: zend_ulong)
     -> zend_bool;
}
extern "C" {
    pub fn zend_hash_move_forward_ex(ht: *mut HashTable,
                                     pos: *mut HashPosition)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_hash_move_backwards_ex(ht: *mut HashTable,
                                       pos: *mut HashPosition)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_hash_get_current_key_ex(ht: *const HashTable,
                                        str_index: *mut *mut zend_string,
                                        num_index: *mut zend_ulong,
                                        pos: *mut HashPosition)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_hash_get_current_key_zval_ex(ht: *const HashTable,
                                             key: *mut zval,
                                             pos: *mut HashPosition);
}
extern "C" {
    pub fn zend_hash_get_current_key_type_ex(ht: *mut HashTable,
                                             pos: *mut HashPosition)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_hash_get_current_data_ex(ht: *mut HashTable,
                                         pos: *mut HashPosition) -> *mut zval;
}
extern "C" {
    pub fn zend_hash_internal_pointer_reset_ex(ht: *mut HashTable,
                                               pos: *mut HashPosition);
}
extern "C" {
    pub fn zend_hash_internal_pointer_end_ex(ht: *mut HashTable,
                                             pos: *mut HashPosition);
}
extern "C" {
    pub fn zend_hash_copy(target: *mut HashTable, source: *mut HashTable,
                          pCopyConstructor: copy_ctor_func_t);
}
extern "C" {
    pub fn _zend_hash_merge(target: *mut HashTable, source: *mut HashTable,
                            pCopyConstructor: copy_ctor_func_t,
                            overwrite: zend_bool);
}
extern "C" {
    pub fn zend_hash_merge_ex(target: *mut HashTable, source: *mut HashTable,
                              pCopyConstructor: copy_ctor_func_t,
                              pMergeSource: merge_checker_func_t,
                              pParam: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn zend_hash_bucket_swap(p: *mut Bucket, q: *mut Bucket);
}
extern "C" {
    pub fn zend_hash_bucket_renum_swap(p: *mut Bucket, q: *mut Bucket);
}
extern "C" {
    pub fn zend_hash_bucket_packed_swap(p: *mut Bucket, q: *mut Bucket);
}
extern "C" {
    pub fn zend_hash_compare(ht1: *mut HashTable, ht2: *mut HashTable,
                             compar: compare_func_t, ordered: zend_bool)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_hash_sort_ex(ht: *mut HashTable, sort_func: sort_func_t,
                             compare_func: compare_func_t,
                             renumber: zend_bool) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_hash_minmax(ht: *const HashTable, compar: compare_func_t,
                            flag: u32) -> *mut zval;
}
extern "C" {
    pub fn zend_hash_rehash(ht: *mut HashTable) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_array_count(ht: *mut HashTable) -> u32;
}
extern "C" {
    pub fn zend_array_dup(source: *mut HashTable) -> *mut HashTable;
}
extern "C" {
    pub fn zend_array_destroy(ht: *mut HashTable);
}
extern "C" {
    pub fn zend_symtable_clean(ht: *mut HashTable);
}
extern "C" {
    pub fn _zend_handle_numeric_str_ex(key: *const ::std::os::raw::c_char,
                                       length: usize, idx: *mut zend_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_hash_iterator_add(ht: *mut HashTable, pos: HashPosition)
     -> u32;
}
extern "C" {
    pub fn zend_hash_iterator_pos(idx: u32, ht: *mut HashTable)
     -> HashPosition;
}
extern "C" {
    pub fn zend_hash_iterator_pos_ex(idx: u32, array: *mut zval)
     -> HashPosition;
}
extern "C" {
    pub fn zend_hash_iterator_del(idx: u32);
}
extern "C" {
    pub fn zend_hash_iterators_lower_pos(ht: *mut HashTable,
                                         start: HashPosition) -> HashPosition;
}
extern "C" {
    pub fn _zend_hash_iterators_update(ht: *mut HashTable, from: HashPosition,
                                       to: HashPosition);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _gc_root_buffer {
    pub ref_: *mut zend_refcounted,
    pub next: *mut _gc_root_buffer,
    pub prev: *mut _gc_root_buffer,
    pub refcount: u32,
}
#[test]
fn bindgen_test_layout__gc_root_buffer() {
    assert_eq!(::std::mem::size_of::<_gc_root_buffer>() , 32usize , concat ! (
               "Size of: " , stringify ! ( _gc_root_buffer ) ));
    assert_eq! (::std::mem::align_of::<_gc_root_buffer>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _gc_root_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _gc_root_buffer ) ) . ref_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _gc_root_buffer ) ,
                "::" , stringify ! ( ref_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _gc_root_buffer ) ) . next as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _gc_root_buffer ) ,
                "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _gc_root_buffer ) ) . prev as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _gc_root_buffer ) ,
                "::" , stringify ! ( prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _gc_root_buffer ) ) . refcount as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _gc_root_buffer ) ,
                "::" , stringify ! ( refcount ) ));
}
impl Clone for _gc_root_buffer {
    fn clone(&self) -> Self { *self }
}
impl Default for _gc_root_buffer {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type gc_root_buffer = _gc_root_buffer;
#[repr(C)]
pub struct _gc_additional_bufer {
    pub used: u32,
    pub next: *mut gc_additional_buffer,
    pub buf: [gc_root_buffer; 127usize],
}
#[test]
fn bindgen_test_layout__gc_additional_bufer() {
    assert_eq!(::std::mem::size_of::<_gc_additional_bufer>() , 4080usize ,
               concat ! ( "Size of: " , stringify ! ( _gc_additional_bufer )
               ));
    assert_eq! (::std::mem::align_of::<_gc_additional_bufer>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _gc_additional_bufer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _gc_additional_bufer ) ) . used as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _gc_additional_bufer )
                , "::" , stringify ! ( used ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _gc_additional_bufer ) ) . next as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _gc_additional_bufer )
                , "::" , stringify ! ( next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _gc_additional_bufer ) ) . buf as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _gc_additional_bufer )
                , "::" , stringify ! ( buf ) ));
}
impl Default for _gc_additional_bufer {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type gc_additional_buffer = _gc_additional_bufer;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _zend_gc_globals {
    pub gc_enabled: zend_bool,
    pub gc_active: zend_bool,
    pub gc_full: zend_bool,
    pub buf: *mut gc_root_buffer,
    pub roots: gc_root_buffer,
    pub unused: *mut gc_root_buffer,
    pub first_unused: *mut gc_root_buffer,
    pub last_unused: *mut gc_root_buffer,
    pub to_free: gc_root_buffer,
    pub next_to_free: *mut gc_root_buffer,
    pub gc_runs: u32,
    pub collected: u32,
    pub additional_buffer: *mut gc_additional_buffer,
}
#[test]
fn bindgen_test_layout__zend_gc_globals() {
    assert_eq!(::std::mem::size_of::<_zend_gc_globals>() , 128usize , concat !
               ( "Size of: " , stringify ! ( _zend_gc_globals ) ));
    assert_eq! (::std::mem::align_of::<_zend_gc_globals>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( _zend_gc_globals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_gc_globals ) ) . gc_enabled as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_gc_globals ) ,
                "::" , stringify ! ( gc_enabled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_gc_globals ) ) . gc_active as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_gc_globals ) ,
                "::" , stringify ! ( gc_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_gc_globals ) ) . gc_full as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_gc_globals ) ,
                "::" , stringify ! ( gc_full ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_gc_globals ) ) . buf as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_gc_globals ) ,
                "::" , stringify ! ( buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_gc_globals ) ) . roots as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_gc_globals ) ,
                "::" , stringify ! ( roots ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_gc_globals ) ) . unused as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_gc_globals ) ,
                "::" , stringify ! ( unused ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_gc_globals ) ) . first_unused as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_gc_globals ) ,
                "::" , stringify ! ( first_unused ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_gc_globals ) ) . last_unused as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_gc_globals ) ,
                "::" , stringify ! ( last_unused ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_gc_globals ) ) . to_free as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_gc_globals ) ,
                "::" , stringify ! ( to_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_gc_globals ) ) . next_to_free as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_gc_globals ) ,
                "::" , stringify ! ( next_to_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_gc_globals ) ) . gc_runs as * const
                _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_gc_globals ) ,
                "::" , stringify ! ( gc_runs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_gc_globals ) ) . collected as *
                const _ as usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_gc_globals ) ,
                "::" , stringify ! ( collected ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_gc_globals ) ) . additional_buffer
                as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_gc_globals ) ,
                "::" , stringify ! ( additional_buffer ) ));
}
impl Clone for _zend_gc_globals {
    fn clone(&self) -> Self { *self }
}
impl Default for _zend_gc_globals {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type zend_gc_globals = _zend_gc_globals;
extern "C" {
    #[link_name = "gc_globals"]
    pub static mut gc_globals: zend_gc_globals;
}
extern "C" {
    #[link_name = "gc_collect_cycles"]
    pub static mut gc_collect_cycles:
               ::std::option::Option<unsafe extern "C" fn()
                                         -> ::std::os::raw::c_int>;
}
extern "C" {
    pub fn gc_possible_root(ref_: *mut zend_refcounted);
}
extern "C" {
    pub fn gc_remove_from_buffer(ref_: *mut zend_refcounted);
}
extern "C" {
    pub fn gc_globals_ctor();
}
extern "C" {
    pub fn gc_globals_dtor();
}
extern "C" {
    pub fn gc_init();
}
extern "C" {
    pub fn gc_reset();
}
extern "C" {
    pub fn zend_gc_collect_cycles() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _zval_dtor_func(p: *mut zend_refcounted);
}
extern "C" {
    pub fn _zval_dtor_func_for_ptr(p: *mut zend_refcounted);
}
extern "C" {
    pub fn _zval_copy_ctor_func(zvalue: *mut zval);
}
extern "C" {
    pub fn zval_copy_static_var(p: *mut zval, num_args: ::std::os::raw::c_int,
                                args: *mut __va_list_tag,
                                key: *mut zend_hash_key)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_print_variable(var: *mut zval) -> usize;
}
extern "C" {
    pub fn _zval_ptr_dtor(zval_ptr: *mut zval);
}
extern "C" {
    pub fn _zval_internal_dtor_for_ptr(zvalue: *mut zval);
}
extern "C" {
    pub fn _zval_internal_dtor(zvalue: *mut zval);
}
extern "C" {
    pub fn _zval_internal_ptr_dtor(zvalue: *mut zval);
}
extern "C" {
    pub fn _zval_dtor_wrapper(zvalue: *mut zval);
}
extern "C" {
    pub fn zval_add_ref(p: *mut zval);
}
extern "C" {
    pub fn zval_add_ref_unref(p: *mut zval);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _zend_object_iterator {
    pub std: zend_object,
    pub data: zval,
    pub funcs: *mut zend_object_iterator_funcs,
    pub index: zend_ulong,
}
#[test]
fn bindgen_test_layout__zend_object_iterator() {
    assert_eq!(::std::mem::size_of::<_zend_object_iterator>() , 88usize ,
               concat ! ( "Size of: " , stringify ! ( _zend_object_iterator )
               ));
    assert_eq! (::std::mem::align_of::<_zend_object_iterator>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _zend_object_iterator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_iterator ) ) . std as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object_iterator )
                , "::" , stringify ! ( std ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_iterator ) ) . data as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object_iterator )
                , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_iterator ) ) . funcs as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object_iterator )
                , "::" , stringify ! ( funcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_iterator ) ) . index as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_object_iterator )
                , "::" , stringify ! ( index ) ));
}
impl Clone for _zend_object_iterator {
    fn clone(&self) -> Self { *self }
}
impl Default for _zend_object_iterator {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type zend_object_iterator = _zend_object_iterator;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _zend_object_iterator_funcs {
    pub dtor: ::std::option::Option<unsafe extern "C" fn(iter:
                                                             *mut zend_object_iterator)>,
    pub valid: ::std::option::Option<unsafe extern "C" fn(iter:
                                                              *mut zend_object_iterator)
                                         -> ::std::os::raw::c_int>,
    pub get_current_data: ::std::option::Option<unsafe extern "C" fn(iter:
                                                                         *mut zend_object_iterator)
                                                    -> *mut zval>,
    pub get_current_key: ::std::option::Option<unsafe extern "C" fn(iter:
                                                                        *mut zend_object_iterator,
                                                                    key:
                                                                        *mut zval)>,
    pub move_forward: ::std::option::Option<unsafe extern "C" fn(iter:
                                                                     *mut zend_object_iterator)>,
    pub rewind: ::std::option::Option<unsafe extern "C" fn(iter:
                                                               *mut zend_object_iterator)>,
    pub invalidate_current: ::std::option::Option<unsafe extern "C" fn(iter:
                                                                           *mut zend_object_iterator)>,
}
#[test]
fn bindgen_test_layout__zend_object_iterator_funcs() {
    assert_eq!(::std::mem::size_of::<_zend_object_iterator_funcs>() , 56usize
               , concat ! (
               "Size of: " , stringify ! ( _zend_object_iterator_funcs ) ));
    assert_eq! (::std::mem::align_of::<_zend_object_iterator_funcs>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _zend_object_iterator_funcs )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_iterator_funcs ) ) . dtor as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_object_iterator_funcs ) , "::" , stringify ! ( dtor )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_iterator_funcs ) ) . valid
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_object_iterator_funcs ) , "::" , stringify ! ( valid )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_iterator_funcs ) ) .
                get_current_data as * const _ as usize } , 16usize , concat !
                (
                "Alignment of field: " , stringify ! (
                _zend_object_iterator_funcs ) , "::" , stringify ! (
                get_current_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_iterator_funcs ) ) .
                get_current_key as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_object_iterator_funcs ) , "::" , stringify ! (
                get_current_key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_iterator_funcs ) ) .
                move_forward as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_object_iterator_funcs ) , "::" , stringify ! (
                move_forward ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_iterator_funcs ) ) . rewind
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_object_iterator_funcs ) , "::" , stringify ! ( rewind )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_object_iterator_funcs ) ) .
                invalidate_current as * const _ as usize } , 48usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                _zend_object_iterator_funcs ) , "::" , stringify ! (
                invalidate_current ) ));
}
impl Clone for _zend_object_iterator_funcs {
    fn clone(&self) -> Self { *self }
}
impl Default for _zend_object_iterator_funcs {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type zend_object_iterator_funcs = _zend_object_iterator_funcs;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _zend_class_iterator_funcs {
    pub funcs: *mut zend_object_iterator_funcs,
    pub zf_new_iterator: *mut _zend_function,
    pub zf_valid: *mut _zend_function,
    pub zf_current: *mut _zend_function,
    pub zf_key: *mut _zend_function,
    pub zf_next: *mut _zend_function,
    pub zf_rewind: *mut _zend_function,
}
#[test]
fn bindgen_test_layout__zend_class_iterator_funcs() {
    assert_eq!(::std::mem::size_of::<_zend_class_iterator_funcs>() , 56usize ,
               concat ! (
               "Size of: " , stringify ! ( _zend_class_iterator_funcs ) ));
    assert_eq! (::std::mem::align_of::<_zend_class_iterator_funcs>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _zend_class_iterator_funcs )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_iterator_funcs ) ) . funcs as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_class_iterator_funcs ) , "::" , stringify ! ( funcs )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_iterator_funcs ) ) .
                zf_new_iterator as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_class_iterator_funcs ) , "::" , stringify ! (
                zf_new_iterator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_iterator_funcs ) ) . zf_valid
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_class_iterator_funcs ) , "::" , stringify ! ( zf_valid )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_iterator_funcs ) ) .
                zf_current as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_class_iterator_funcs ) , "::" , stringify ! ( zf_current
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_iterator_funcs ) ) . zf_key
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_class_iterator_funcs ) , "::" , stringify ! ( zf_key )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_iterator_funcs ) ) . zf_next
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_class_iterator_funcs ) , "::" , stringify ! ( zf_next )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_class_iterator_funcs ) ) .
                zf_rewind as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_class_iterator_funcs ) , "::" , stringify ! ( zf_rewind
                ) ));
}
impl Clone for _zend_class_iterator_funcs {
    fn clone(&self) -> Self { *self }
}
impl Default for _zend_class_iterator_funcs {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type zend_class_iterator_funcs = _zend_class_iterator_funcs;
extern "C" {
    pub fn zend_iterator_unwrap(array_ptr: *mut zval)
     -> *mut zend_object_iterator;
}
extern "C" {
    pub fn zend_iterator_init(iter: *mut zend_object_iterator);
}
extern "C" {
    pub fn zend_iterator_dtor(iter: *mut zend_object_iterator);
}
extern "C" {
    pub fn zend_register_iterator_wrapper();
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: ::std::os::raw::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
#[test]
fn bindgen_test_layout_stat() {
    assert_eq!(::std::mem::size_of::<stat>() , 144usize , concat ! (
               "Size of: " , stringify ! ( stat ) ));
    assert_eq! (::std::mem::align_of::<stat>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( stat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_dev as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_dev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_ino as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_ino ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_nlink as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_nlink ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_mode as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_uid as * const _ as usize }
                , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_gid as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_gid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . __pad0 as * const _ as usize }
                , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( __pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_rdev as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_rdev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_size as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_blksize as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_blksize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_blocks as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_blocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_atim as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_atim ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_mtim as * const _ as usize
                } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_mtim ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . st_ctim as * const _ as usize
                } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( st_ctim ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat ) ) . __glibc_reserved as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( stat ) , "::" ,
                stringify ! ( __glibc_reserved ) ));
}
impl Clone for stat {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct stat64 {
    pub st_dev: __dev_t,
    pub st_ino: __ino64_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: ::std::os::raw::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt64_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
#[test]
fn bindgen_test_layout_stat64() {
    assert_eq!(::std::mem::size_of::<stat64>() , 144usize , concat ! (
               "Size of: " , stringify ! ( stat64 ) ));
    assert_eq! (::std::mem::align_of::<stat64>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( stat64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat64 ) ) . st_dev as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( stat64 ) , "::" ,
                stringify ! ( st_dev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat64 ) ) . st_ino as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( stat64 ) , "::" ,
                stringify ! ( st_ino ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat64 ) ) . st_nlink as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( stat64 ) , "::" ,
                stringify ! ( st_nlink ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat64 ) ) . st_mode as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( stat64 ) , "::" ,
                stringify ! ( st_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat64 ) ) . st_uid as * const _ as usize
                } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( stat64 ) , "::" ,
                stringify ! ( st_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat64 ) ) . st_gid as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( stat64 ) , "::" ,
                stringify ! ( st_gid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat64 ) ) . __pad0 as * const _ as usize
                } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( stat64 ) , "::" ,
                stringify ! ( __pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat64 ) ) . st_rdev as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( stat64 ) , "::" ,
                stringify ! ( st_rdev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat64 ) ) . st_size as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( stat64 ) , "::" ,
                stringify ! ( st_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat64 ) ) . st_blksize as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( stat64 ) , "::" ,
                stringify ! ( st_blksize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat64 ) ) . st_blocks as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( stat64 ) , "::" ,
                stringify ! ( st_blocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat64 ) ) . st_atim as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( stat64 ) , "::" ,
                stringify ! ( st_atim ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat64 ) ) . st_mtim as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( stat64 ) , "::" ,
                stringify ! ( st_mtim ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat64 ) ) . st_ctim as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( stat64 ) , "::" ,
                stringify ! ( st_ctim ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const stat64 ) ) . __glibc_reserved as * const
                _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( stat64 ) , "::" ,
                stringify ! ( __glibc_reserved ) ));
}
impl Clone for stat64 {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn stat(__file: *const ::std::os::raw::c_char, __buf: *mut stat)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstat(__fd: ::std::os::raw::c_int, __buf: *mut stat)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stat64(__file: *const ::std::os::raw::c_char, __buf: *mut stat64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstat64(__fd: ::std::os::raw::c_int, __buf: *mut stat64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstatat(__fd: ::std::os::raw::c_int,
                   __file: *const ::std::os::raw::c_char, __buf: *mut stat,
                   __flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fstatat64(__fd: ::std::os::raw::c_int,
                     __file: *const ::std::os::raw::c_char,
                     __buf: *mut stat64, __flag: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lstat(__file: *const ::std::os::raw::c_char, __buf: *mut stat)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lstat64(__file: *const ::std::os::raw::c_char, __buf: *mut stat64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chmod(__file: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchmod(__file: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmod(__fd: ::std::os::raw::c_int, __mode: __mode_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchmodat(__fd: ::std::os::raw::c_int,
                    __file: *const ::std::os::raw::c_char, __mode: __mode_t,
                    __flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn umask(__mask: __mode_t) -> __mode_t;
}
extern "C" {
    pub fn getumask() -> __mode_t;
}
extern "C" {
    pub fn mkdir(__path: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdirat(__fd: ::std::os::raw::c_int,
                   __path: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mknod(__path: *const ::std::os::raw::c_char, __mode: __mode_t,
                 __dev: __dev_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mknodat(__fd: ::std::os::raw::c_int,
                   __path: *const ::std::os::raw::c_char, __mode: __mode_t,
                   __dev: __dev_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifo(__path: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkfifoat(__fd: ::std::os::raw::c_int,
                    __path: *const ::std::os::raw::c_char, __mode: __mode_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimensat(__fd: ::std::os::raw::c_int,
                     __path: *const ::std::os::raw::c_char,
                     __times: *const timespec, __flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimens(__fd: ::std::os::raw::c_int, __times: *const timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fxstat(__ver: ::std::os::raw::c_int,
                    __fildes: ::std::os::raw::c_int, __stat_buf: *mut stat)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xstat(__ver: ::std::os::raw::c_int,
                   __filename: *const ::std::os::raw::c_char,
                   __stat_buf: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __lxstat(__ver: ::std::os::raw::c_int,
                    __filename: *const ::std::os::raw::c_char,
                    __stat_buf: *mut stat) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fxstatat(__ver: ::std::os::raw::c_int,
                      __fildes: ::std::os::raw::c_int,
                      __filename: *const ::std::os::raw::c_char,
                      __stat_buf: *mut stat, __flag: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fxstat64(__ver: ::std::os::raw::c_int,
                      __fildes: ::std::os::raw::c_int,
                      __stat_buf: *mut stat64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xstat64(__ver: ::std::os::raw::c_int,
                     __filename: *const ::std::os::raw::c_char,
                     __stat_buf: *mut stat64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __lxstat64(__ver: ::std::os::raw::c_int,
                      __filename: *const ::std::os::raw::c_char,
                      __stat_buf: *mut stat64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fxstatat64(__ver: ::std::os::raw::c_int,
                        __fildes: ::std::os::raw::c_int,
                        __filename: *const ::std::os::raw::c_char,
                        __stat_buf: *mut stat64,
                        __flag: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xmknod(__ver: ::std::os::raw::c_int,
                    __path: *const ::std::os::raw::c_char, __mode: __mode_t,
                    __dev: *mut __dev_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __xmknodat(__ver: ::std::os::raw::c_int,
                      __fd: ::std::os::raw::c_int,
                      __path: *const ::std::os::raw::c_char, __mode: __mode_t,
                      __dev: *mut __dev_t) -> ::std::os::raw::c_int;
}
pub type zend_stream_fsizer_t =
    ::std::option::Option<unsafe extern "C" fn(handle:
                                                   *mut ::std::os::raw::c_void)
                              -> usize>;
pub type zend_stream_reader_t =
    ::std::option::Option<unsafe extern "C" fn(handle:
                                                   *mut ::std::os::raw::c_void,
                                               buf:
                                                   *mut ::std::os::raw::c_char,
                                               len: usize) -> usize>;
pub type zend_stream_closer_t =
    ::std::option::Option<unsafe extern "C" fn(handle:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zend_stream_type {
    ZEND_HANDLE_FILENAME = 0,
    ZEND_HANDLE_FD = 1,
    ZEND_HANDLE_FP = 2,
    ZEND_HANDLE_STREAM = 3,
    ZEND_HANDLE_MAPPED = 4,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _zend_mmap {
    pub len: usize,
    pub pos: usize,
    pub map: *mut ::std::os::raw::c_void,
    pub buf: *mut ::std::os::raw::c_char,
    pub old_handle: *mut ::std::os::raw::c_void,
    pub old_closer: zend_stream_closer_t,
}
#[test]
fn bindgen_test_layout__zend_mmap() {
    assert_eq!(::std::mem::size_of::<_zend_mmap>() , 48usize , concat ! (
               "Size of: " , stringify ! ( _zend_mmap ) ));
    assert_eq! (::std::mem::align_of::<_zend_mmap>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _zend_mmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_mmap ) ) . len as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_mmap ) , "::" ,
                stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_mmap ) ) . pos as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_mmap ) , "::" ,
                stringify ! ( pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_mmap ) ) . map as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_mmap ) , "::" ,
                stringify ! ( map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_mmap ) ) . buf as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_mmap ) , "::" ,
                stringify ! ( buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_mmap ) ) . old_handle as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_mmap ) , "::" ,
                stringify ! ( old_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_mmap ) ) . old_closer as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_mmap ) , "::" ,
                stringify ! ( old_closer ) ));
}
impl Clone for _zend_mmap {
    fn clone(&self) -> Self { *self }
}
impl Default for _zend_mmap {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type zend_mmap = _zend_mmap;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _zend_stream {
    pub handle: *mut ::std::os::raw::c_void,
    pub isatty: ::std::os::raw::c_int,
    pub mmap: zend_mmap,
    pub reader: zend_stream_reader_t,
    pub fsizer: zend_stream_fsizer_t,
    pub closer: zend_stream_closer_t,
}
#[test]
fn bindgen_test_layout__zend_stream() {
    assert_eq!(::std::mem::size_of::<_zend_stream>() , 88usize , concat ! (
               "Size of: " , stringify ! ( _zend_stream ) ));
    assert_eq! (::std::mem::align_of::<_zend_stream>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _zend_stream ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_stream ) ) . handle as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_stream ) , "::" ,
                stringify ! ( handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_stream ) ) . isatty as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_stream ) , "::" ,
                stringify ! ( isatty ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_stream ) ) . mmap as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_stream ) , "::" ,
                stringify ! ( mmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_stream ) ) . reader as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_stream ) , "::" ,
                stringify ! ( reader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_stream ) ) . fsizer as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_stream ) , "::" ,
                stringify ! ( fsizer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_stream ) ) . closer as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_stream ) , "::" ,
                stringify ! ( closer ) ));
}
impl Clone for _zend_stream {
    fn clone(&self) -> Self { *self }
}
impl Default for _zend_stream {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type zend_stream = _zend_stream;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _zend_file_handle {
    pub handle: _zend_file_handle__bindgen_ty_1,
    pub filename: *const ::std::os::raw::c_char,
    pub opened_path: *mut zend_string,
    pub type_: zend_stream_type,
    pub free_filename: zend_bool,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _zend_file_handle__bindgen_ty_1 {
    pub fd: __BindgenUnionField<::std::os::raw::c_int>,
    pub fp: __BindgenUnionField<*mut FILE>,
    pub stream: __BindgenUnionField<zend_stream>,
    pub bindgen_union_field: [u64; 11usize],
}
#[test]
fn bindgen_test_layout__zend_file_handle__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_zend_file_handle__bindgen_ty_1>() ,
               88usize , concat ! (
               "Size of: " , stringify ! ( _zend_file_handle__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<_zend_file_handle__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                _zend_file_handle__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_file_handle__bindgen_ty_1 ) ) . fd
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_file_handle__bindgen_ty_1 ) , "::" , stringify ! ( fd )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_file_handle__bindgen_ty_1 ) ) . fp
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_file_handle__bindgen_ty_1 ) , "::" , stringify ! ( fp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_file_handle__bindgen_ty_1 ) ) .
                stream as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_file_handle__bindgen_ty_1 ) , "::" , stringify ! (
                stream ) ));
}
impl Clone for _zend_file_handle__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__zend_file_handle() {
    assert_eq!(::std::mem::size_of::<_zend_file_handle>() , 112usize , concat
               ! ( "Size of: " , stringify ! ( _zend_file_handle ) ));
    assert_eq! (::std::mem::align_of::<_zend_file_handle>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _zend_file_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_file_handle ) ) . handle as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_file_handle ) ,
                "::" , stringify ! ( handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_file_handle ) ) . filename as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_file_handle ) ,
                "::" , stringify ! ( filename ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_file_handle ) ) . opened_path as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_file_handle ) ,
                "::" , stringify ! ( opened_path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_file_handle ) ) . type_ as * const
                _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_file_handle ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_file_handle ) ) . free_filename as
                * const _ as usize } , 108usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_file_handle ) ,
                "::" , stringify ! ( free_filename ) ));
}
impl Clone for _zend_file_handle {
    fn clone(&self) -> Self { *self }
}
impl Default for _zend_file_handle {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type zend_file_handle = _zend_file_handle;
extern "C" {
    pub fn zend_stream_open(filename: *const ::std::os::raw::c_char,
                            handle: *mut zend_file_handle)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_stream_fixup(file_handle: *mut zend_file_handle,
                             buf: *mut *mut ::std::os::raw::c_char,
                             len: *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_file_handle_dtor(fh: *mut zend_file_handle);
}
extern "C" {
    pub fn zend_compare_file_handles(fh1: *mut zend_file_handle,
                                     fh2: *mut zend_file_handle)
     -> ::std::os::raw::c_int;
}
pub type zend_stat_t = stat;
extern "C" {
    pub fn zend_error_noreturn(type_: ::std::os::raw::c_int,
                               format: *const ::std::os::raw::c_char, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _zend_serialize_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _zend_unserialize_data {
    _unused: [u8; 0],
}
pub type zend_serialize_data = _zend_serialize_data;
pub type zend_unserialize_data = _zend_unserialize_data;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _zend_trait_method_reference {
    pub method_name: *mut zend_string,
    pub ce: *mut zend_class_entry,
    pub class_name: *mut zend_string,
}
#[test]
fn bindgen_test_layout__zend_trait_method_reference() {
    assert_eq!(::std::mem::size_of::<_zend_trait_method_reference>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( _zend_trait_method_reference ) ));
    assert_eq! (::std::mem::align_of::<_zend_trait_method_reference>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _zend_trait_method_reference )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_trait_method_reference ) ) .
                method_name as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_trait_method_reference ) , "::" , stringify ! (
                method_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_trait_method_reference ) ) . ce as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_trait_method_reference ) , "::" , stringify ! ( ce ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_trait_method_reference ) ) .
                class_name as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_trait_method_reference ) , "::" , stringify ! (
                class_name ) ));
}
impl Clone for _zend_trait_method_reference {
    fn clone(&self) -> Self { *self }
}
impl Default for _zend_trait_method_reference {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type zend_trait_method_reference = _zend_trait_method_reference;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _zend_trait_precedence {
    pub trait_method: *mut zend_trait_method_reference,
    pub exclude_from_classes: *mut _zend_trait_precedence__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _zend_trait_precedence__bindgen_ty_1 {
    pub ce: __BindgenUnionField<*mut zend_class_entry>,
    pub class_name: __BindgenUnionField<*mut zend_string>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__zend_trait_precedence__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_zend_trait_precedence__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! (
               _zend_trait_precedence__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<_zend_trait_precedence__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                _zend_trait_precedence__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_trait_precedence__bindgen_ty_1 ) )
                . ce as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_trait_precedence__bindgen_ty_1 ) , "::" , stringify ! (
                ce ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_trait_precedence__bindgen_ty_1 ) )
                . class_name as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _zend_trait_precedence__bindgen_ty_1 ) , "::" , stringify ! (
                class_name ) ));
}
impl Clone for _zend_trait_precedence__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__zend_trait_precedence() {
    assert_eq!(::std::mem::size_of::<_zend_trait_precedence>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( _zend_trait_precedence )
               ));
    assert_eq! (::std::mem::align_of::<_zend_trait_precedence>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _zend_trait_precedence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_trait_precedence ) ) . trait_method
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_trait_precedence
                ) , "::" , stringify ! ( trait_method ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_trait_precedence ) ) .
                exclude_from_classes as * const _ as usize } , 8usize , concat
                ! (
                "Alignment of field: " , stringify ! ( _zend_trait_precedence
                ) , "::" , stringify ! ( exclude_from_classes ) ));
}
impl Clone for _zend_trait_precedence {
    fn clone(&self) -> Self { *self }
}
impl Default for _zend_trait_precedence {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type zend_trait_precedence = _zend_trait_precedence;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _zend_trait_alias {
    pub trait_method: *mut zend_trait_method_reference,
    /// name for method to be added
    pub alias: *mut zend_string,
    /// modifiers to be set on trait method
    pub modifiers: u32,
}
#[test]
fn bindgen_test_layout__zend_trait_alias() {
    assert_eq!(::std::mem::size_of::<_zend_trait_alias>() , 24usize , concat !
               ( "Size of: " , stringify ! ( _zend_trait_alias ) ));
    assert_eq! (::std::mem::align_of::<_zend_trait_alias>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _zend_trait_alias ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_trait_alias ) ) . trait_method as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_trait_alias ) ,
                "::" , stringify ! ( trait_method ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_trait_alias ) ) . alias as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_trait_alias ) ,
                "::" , stringify ! ( alias ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_trait_alias ) ) . modifiers as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_trait_alias ) ,
                "::" , stringify ! ( modifiers ) ));
}
impl Clone for _zend_trait_alias {
    fn clone(&self) -> Self { *self }
}
impl Default for _zend_trait_alias {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type zend_trait_alias = _zend_trait_alias;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _zend_utility_functions {
    pub error_function: ::std::option::Option<unsafe extern "C" fn(type_:
                                                                       ::std::os::raw::c_int,
                                                                   error_filename:
                                                                       *const ::std::os::raw::c_char,
                                                                   error_lineno:
                                                                       uint,
                                                                   format:
                                                                       *const ::std::os::raw::c_char,
                                                                   args:
                                                                       *mut __va_list_tag)>,
    pub printf_function: ::std::option::Option<unsafe extern "C" fn(format:
                                                                        *const ::std::os::raw::c_char, ...)
                                                   -> usize>,
    pub write_function: ::std::option::Option<unsafe extern "C" fn(str:
                                                                       *const ::std::os::raw::c_char,
                                                                   str_length:
                                                                       usize)
                                                  -> usize>,
    pub fopen_function: ::std::option::Option<unsafe extern "C" fn(filename:
                                                                       *const ::std::os::raw::c_char,
                                                                   opened_path:
                                                                       *mut *mut zend_string)
                                                  -> *mut FILE>,
    pub message_handler: ::std::option::Option<unsafe extern "C" fn(message:
                                                                        zend_long,
                                                                    data:
                                                                        *const ::std::os::raw::c_void)>,
    pub block_interruptions: ::std::option::Option<unsafe extern "C" fn()>,
    pub unblock_interruptions: ::std::option::Option<unsafe extern "C" fn()>,
    pub get_configuration_directive: ::std::option::Option<unsafe extern "C" fn(name:
                                                                                    *mut zend_string)
                                                               -> *mut zval>,
    pub ticks_function: ::std::option::Option<unsafe extern "C" fn(ticks:
                                                                       ::std::os::raw::c_int)>,
    pub on_timeout: ::std::option::Option<unsafe extern "C" fn(seconds:
                                                                   ::std::os::raw::c_int)>,
    pub stream_open_function: ::std::option::Option<unsafe extern "C" fn(filename:
                                                                             *const ::std::os::raw::c_char,
                                                                         handle:
                                                                             *mut zend_file_handle)
                                                        ->
                                                            ::std::os::raw::c_int>,
    pub vspprintf_function: ::std::option::Option<unsafe extern "C" fn(pbuf:
                                                                           *mut *mut ::std::os::raw::c_char,
                                                                       max_len:
                                                                           usize,
                                                                       format:
                                                                           *const ::std::os::raw::c_char,
                                                                       ap:
                                                                           *mut __va_list_tag)
                                                      -> usize>,
    pub vstrpprintf_function: ::std::option::Option<unsafe extern "C" fn(max_len:
                                                                             usize,
                                                                         format:
                                                                             *const ::std::os::raw::c_char,
                                                                         ap:
                                                                             *mut __va_list_tag)
                                                        -> *mut zend_string>,
    pub getenv_function: ::std::option::Option<unsafe extern "C" fn(name:
                                                                        *mut ::std::os::raw::c_char,
                                                                    name_len:
                                                                        usize)
                                                   ->
                                                       *mut ::std::os::raw::c_char>,
    pub resolve_path_function: ::std::option::Option<unsafe extern "C" fn(filename:
                                                                              *const ::std::os::raw::c_char,
                                                                          filename_len:
                                                                              ::std::os::raw::c_int)
                                                         -> *mut zend_string>,
}
#[test]
fn bindgen_test_layout__zend_utility_functions() {
    assert_eq!(::std::mem::size_of::<_zend_utility_functions>() , 120usize ,
               concat ! (
               "Size of: " , stringify ! ( _zend_utility_functions ) ));
    assert_eq! (::std::mem::align_of::<_zend_utility_functions>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _zend_utility_functions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_utility_functions ) ) .
                error_function as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_utility_functions
                ) , "::" , stringify ! ( error_function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_utility_functions ) ) .
                printf_function as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_utility_functions
                ) , "::" , stringify ! ( printf_function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_utility_functions ) ) .
                write_function as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_utility_functions
                ) , "::" , stringify ! ( write_function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_utility_functions ) ) .
                fopen_function as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_utility_functions
                ) , "::" , stringify ! ( fopen_function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_utility_functions ) ) .
                message_handler as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_utility_functions
                ) , "::" , stringify ! ( message_handler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_utility_functions ) ) .
                block_interruptions as * const _ as usize } , 40usize , concat
                ! (
                "Alignment of field: " , stringify ! ( _zend_utility_functions
                ) , "::" , stringify ! ( block_interruptions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_utility_functions ) ) .
                unblock_interruptions as * const _ as usize } , 48usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _zend_utility_functions
                ) , "::" , stringify ! ( unblock_interruptions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_utility_functions ) ) .
                get_configuration_directive as * const _ as usize } , 56usize
                , concat ! (
                "Alignment of field: " , stringify ! ( _zend_utility_functions
                ) , "::" , stringify ! ( get_configuration_directive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_utility_functions ) ) .
                ticks_function as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_utility_functions
                ) , "::" , stringify ! ( ticks_function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_utility_functions ) ) . on_timeout
                as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_utility_functions
                ) , "::" , stringify ! ( on_timeout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_utility_functions ) ) .
                stream_open_function as * const _ as usize } , 80usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _zend_utility_functions
                ) , "::" , stringify ! ( stream_open_function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_utility_functions ) ) .
                vspprintf_function as * const _ as usize } , 88usize , concat
                ! (
                "Alignment of field: " , stringify ! ( _zend_utility_functions
                ) , "::" , stringify ! ( vspprintf_function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_utility_functions ) ) .
                vstrpprintf_function as * const _ as usize } , 96usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _zend_utility_functions
                ) , "::" , stringify ! ( vstrpprintf_function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_utility_functions ) ) .
                getenv_function as * const _ as usize } , 104usize , concat !
                (
                "Alignment of field: " , stringify ! ( _zend_utility_functions
                ) , "::" , stringify ! ( getenv_function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_utility_functions ) ) .
                resolve_path_function as * const _ as usize } , 112usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _zend_utility_functions
                ) , "::" , stringify ! ( resolve_path_function ) ));
}
impl Clone for _zend_utility_functions {
    fn clone(&self) -> Self { *self }
}
impl Default for _zend_utility_functions {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type zend_utility_functions = _zend_utility_functions;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _zend_utility_values {
    pub import_use_extension: *mut ::std::os::raw::c_char,
    pub import_use_extension_length: uint,
    pub html_errors: zend_bool,
}
#[test]
fn bindgen_test_layout__zend_utility_values() {
    assert_eq!(::std::mem::size_of::<_zend_utility_values>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( _zend_utility_values )
               ));
    assert_eq! (::std::mem::align_of::<_zend_utility_values>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _zend_utility_values ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_utility_values ) ) .
                import_use_extension as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! ( _zend_utility_values )
                , "::" , stringify ! ( import_use_extension ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_utility_values ) ) .
                import_use_extension_length as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( _zend_utility_values )
                , "::" , stringify ! ( import_use_extension_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_utility_values ) ) . html_errors as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_utility_values )
                , "::" , stringify ! ( html_errors ) ));
}
impl Clone for _zend_utility_values {
    fn clone(&self) -> Self { *self }
}
impl Default for _zend_utility_values {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type zend_utility_values = _zend_utility_values;
pub type zend_write_func_t =
    ::std::option::Option<unsafe extern "C" fn(str:
                                                   *const ::std::os::raw::c_char,
                                               str_length: usize)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn zend_startup(utility_functions: *mut zend_utility_functions,
                        extensions: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_shutdown();
}
extern "C" {
    pub fn zend_register_standard_ini_entries();
}
extern "C" {
    pub fn zend_post_startup();
}
extern "C" {
    pub fn zend_set_utility_values(utility_values: *mut zend_utility_values);
}
extern "C" {
    pub fn _zend_bailout(filename: *mut ::std::os::raw::c_char, lineno: uint);
}
extern "C" {
    pub fn get_zend_version() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn zend_make_printable_zval(expr: *mut zval, expr_copy: *mut zval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_print_zval(expr: *mut zval, indent: ::std::os::raw::c_int)
     -> usize;
}
extern "C" {
    pub fn zend_print_zval_ex(write_func: zend_write_func_t, expr: *mut zval,
                              indent: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    pub fn zend_print_zval_r(expr: *mut zval, indent: ::std::os::raw::c_int);
}
extern "C" {
    pub fn zend_print_flat_zval_r(expr: *mut zval);
}
extern "C" {
    pub fn zend_print_zval_r_ex(write_func: zend_write_func_t,
                                expr: *mut zval,
                                indent: ::std::os::raw::c_int);
}
extern "C" {
    pub fn zend_output_debug_string(trigger_break: zend_bool,
                                    format:
                                        *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn zend_activate();
}
extern "C" {
    pub fn zend_deactivate();
}
extern "C" {
    pub fn zend_call_destructors();
}
extern "C" {
    pub fn zend_activate_modules();
}
extern "C" {
    pub fn zend_deactivate_modules();
}
extern "C" {
    pub fn zend_post_deactivate_modules();
}
extern "C" {
    pub fn free_estring(str_p: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "zend_printf"]
    pub static mut zend_printf:
               ::std::option::Option<unsafe extern "C" fn(format:
                                                              *const ::std::os::raw::c_char, ...)
                                         -> usize>;
}
extern "C" {
    #[link_name = "zend_write"]
    pub static mut zend_write: zend_write_func_t;
}
extern "C" {
    #[link_name = "zend_fopen"]
    pub static mut zend_fopen:
               ::std::option::Option<unsafe extern "C" fn(filename:
                                                              *const ::std::os::raw::c_char,
                                                          opened_path:
                                                              *mut *mut zend_string)
                                         -> *mut FILE>;
}
extern "C" {
    #[link_name = "zend_block_interruptions"]
    pub static mut zend_block_interruptions:
               ::std::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    #[link_name = "zend_unblock_interruptions"]
    pub static mut zend_unblock_interruptions:
               ::std::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    #[link_name = "zend_ticks_function"]
    pub static mut zend_ticks_function:
               ::std::option::Option<unsafe extern "C" fn(ticks:
                                                              ::std::os::raw::c_int)>;
}
extern "C" {
    #[link_name = "zend_error_cb"]
    pub static mut zend_error_cb:
               ::std::option::Option<unsafe extern "C" fn(type_:
                                                              ::std::os::raw::c_int,
                                                          error_filename:
                                                              *const ::std::os::raw::c_char,
                                                          error_lineno: uint,
                                                          format:
                                                              *const ::std::os::raw::c_char,
                                                          args:
                                                              *mut __va_list_tag)>;
}
extern "C" {
    #[link_name = "zend_on_timeout"]
    pub static mut zend_on_timeout:
               ::std::option::Option<unsafe extern "C" fn(seconds:
                                                              ::std::os::raw::c_int)>;
}
extern "C" {
    #[link_name = "zend_stream_open_function"]
    pub static mut zend_stream_open_function:
               ::std::option::Option<unsafe extern "C" fn(filename:
                                                              *const ::std::os::raw::c_char,
                                                          handle:
                                                              *mut zend_file_handle)
                                         -> ::std::os::raw::c_int>;
}
extern "C" {
    #[link_name = "zend_vspprintf"]
    pub static mut zend_vspprintf:
               ::std::option::Option<unsafe extern "C" fn(pbuf:
                                                              *mut *mut ::std::os::raw::c_char,
                                                          max_len: usize,
                                                          format:
                                                              *const ::std::os::raw::c_char,
                                                          ap:
                                                              *mut __va_list_tag)
                                         -> usize>;
}
extern "C" {
    #[link_name = "zend_vstrpprintf"]
    pub static mut zend_vstrpprintf:
               ::std::option::Option<unsafe extern "C" fn(max_len: usize,
                                                          format:
                                                              *const ::std::os::raw::c_char,
                                                          ap:
                                                              *mut __va_list_tag)
                                         -> *mut zend_string>;
}
extern "C" {
    #[link_name = "zend_getenv"]
    pub static mut zend_getenv:
               ::std::option::Option<unsafe extern "C" fn(name:
                                                              *mut ::std::os::raw::c_char,
                                                          name_len: usize)
                                         -> *mut ::std::os::raw::c_char>;
}
extern "C" {
    #[link_name = "zend_resolve_path"]
    pub static mut zend_resolve_path:
               ::std::option::Option<unsafe extern "C" fn(filename:
                                                              *const ::std::os::raw::c_char,
                                                          filename_len:
                                                              ::std::os::raw::c_int)
                                         -> *mut zend_string>;
}
extern "C" {
    pub fn zend_error(type_: ::std::os::raw::c_int,
                      format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn zend_throw_error(exception_ce: *mut zend_class_entry,
                            format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn zend_type_error(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn zend_internal_type_error(throw_exception: zend_bool,
                                    format:
                                        *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn zenderror(error: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "zend_standard_class_def"]
    pub static mut zend_standard_class_def: *mut zend_class_entry;
}
extern "C" {
    #[link_name = "zend_uv"]
    pub static mut zend_uv: zend_utility_values;
}
extern "C" {
    #[link_name = "zval_used_for_init"]
    pub static mut zval_used_for_init: zval;
}
extern "C" {
    #[link_name = "zend_dtrace_enabled"]
    pub static mut zend_dtrace_enabled: zend_bool;
}
extern "C" {
    pub fn zend_message_dispatcher(message: zend_long,
                                   data: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn zend_get_configuration_directive(name: *mut zend_string)
     -> *mut zval;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum zend_error_handling_t {
    EH_NORMAL = 0,
    EH_SUPPRESS = 1,
    EH_THROW = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct zend_error_handling {
    pub handling: zend_error_handling_t,
    pub exception: *mut zend_class_entry,
    pub user_handler: zval,
}
#[test]
fn bindgen_test_layout_zend_error_handling() {
    assert_eq!(::std::mem::size_of::<zend_error_handling>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( zend_error_handling ) ));
    assert_eq! (::std::mem::align_of::<zend_error_handling>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( zend_error_handling ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zend_error_handling ) ) . handling as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( zend_error_handling ) ,
                "::" , stringify ! ( handling ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zend_error_handling ) ) . exception as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( zend_error_handling ) ,
                "::" , stringify ! ( exception ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const zend_error_handling ) ) . user_handler as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( zend_error_handling ) ,
                "::" , stringify ! ( user_handler ) ));
}
impl Clone for zend_error_handling {
    fn clone(&self) -> Self { *self }
}
impl Default for zend_error_handling {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn zend_save_error_handling(current: *mut zend_error_handling);
}
extern "C" {
    pub fn zend_replace_error_handling(error_handling: zend_error_handling_t,
                                       exception_class: *mut zend_class_entry,
                                       current: *mut zend_error_handling);
}
extern "C" {
    pub fn zend_restore_error_handling(saved: *mut zend_error_handling);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _zend_property_info {
    _unused: [u8; 0],
}
pub type zend_object_read_property_t =
    ::std::option::Option<unsafe extern "C" fn(object: *mut zval,
                                               member: *mut zval,
                                               type_: ::std::os::raw::c_int,
                                               cache_slot:
                                                   *mut *mut ::std::os::raw::c_void,
                                               rv: *mut zval) -> *mut zval>;
pub type zend_object_read_dimension_t =
    ::std::option::Option<unsafe extern "C" fn(object: *mut zval,
                                               offset: *mut zval,
                                               type_: ::std::os::raw::c_int,
                                               rv: *mut zval) -> *mut zval>;
pub type zend_object_write_property_t =
    ::std::option::Option<unsafe extern "C" fn(object: *mut zval,
                                               member: *mut zval,
                                               value: *mut zval,
                                               cache_slot:
                                                   *mut *mut ::std::os::raw::c_void)>;
pub type zend_object_write_dimension_t =
    ::std::option::Option<unsafe extern "C" fn(object: *mut zval,
                                               offset: *mut zval,
                                               value: *mut zval)>;
pub type zend_object_get_property_ptr_ptr_t =
    ::std::option::Option<unsafe extern "C" fn(object: *mut zval,
                                               member: *mut zval,
                                               type_: ::std::os::raw::c_int,
                                               cache_slot:
                                                   *mut *mut ::std::os::raw::c_void)
                              -> *mut zval>;
pub type zend_object_set_t =
    ::std::option::Option<unsafe extern "C" fn(object: *mut zval,
                                               value: *mut zval)>;
pub type zend_object_get_t =
    ::std::option::Option<unsafe extern "C" fn(object: *mut zval,
                                               rv: *mut zval) -> *mut zval>;
pub type zend_object_has_property_t =
    ::std::option::Option<unsafe extern "C" fn(object: *mut zval,
                                               member: *mut zval,
                                               has_set_exists:
                                                   ::std::os::raw::c_int,
                                               cache_slot:
                                                   *mut *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type zend_object_has_dimension_t =
    ::std::option::Option<unsafe extern "C" fn(object: *mut zval,
                                               member: *mut zval,
                                               check_empty:
                                                   ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
pub type zend_object_unset_property_t =
    ::std::option::Option<unsafe extern "C" fn(object: *mut zval,
                                               member: *mut zval,
                                               cache_slot:
                                                   *mut *mut ::std::os::raw::c_void)>;
pub type zend_object_unset_dimension_t =
    ::std::option::Option<unsafe extern "C" fn(object: *mut zval,
                                               offset: *mut zval)>;
pub type zend_object_get_properties_t =
    ::std::option::Option<unsafe extern "C" fn(object: *mut zval)
                              -> *mut HashTable>;
pub type zend_object_get_debug_info_t =
    ::std::option::Option<unsafe extern "C" fn(object: *mut zval,
                                               is_temp:
                                                   *mut ::std::os::raw::c_int)
                              -> *mut HashTable>;
pub type zend_object_call_method_t =
    ::std::option::Option<unsafe extern "C" fn(method: *mut zend_string,
                                               object: *mut zend_object,
                                               execute_data:
                                                   *mut zend_execute_data,
                                               return_value: *mut zval)
                              -> ::std::os::raw::c_int>;
pub type zend_object_get_method_t =
    ::std::option::Option<unsafe extern "C" fn(object: *mut *mut zend_object,
                                               method: *mut zend_string,
                                               key: *const zval)
                              -> *mut _zend_function>;
pub type zend_object_get_constructor_t =
    ::std::option::Option<unsafe extern "C" fn(object: *mut zend_object)
                              -> *mut _zend_function>;
pub type zend_object_dtor_obj_t =
    ::std::option::Option<unsafe extern "C" fn(object: *mut zend_object)>;
pub type zend_object_free_obj_t =
    ::std::option::Option<unsafe extern "C" fn(object: *mut zend_object)>;
pub type zend_object_clone_obj_t =
    ::std::option::Option<unsafe extern "C" fn(object: *mut zval)
                              -> *mut zend_object>;
pub type zend_object_get_class_name_t =
    ::std::option::Option<unsafe extern "C" fn(object: *const zend_object)
                              -> *mut zend_string>;
pub type zend_object_compare_t =
    ::std::option::Option<unsafe extern "C" fn(object1: *mut zval,
                                               object2: *mut zval)
                              -> ::std::os::raw::c_int>;
pub type zend_object_compare_zvals_t =
    ::std::option::Option<unsafe extern "C" fn(resul: *mut zval,
                                               op1: *mut zval, op2: *mut zval)
                              -> ::std::os::raw::c_int>;
pub type zend_object_cast_t =
    ::std::option::Option<unsafe extern "C" fn(readobj: *mut zval,
                                               retval: *mut zval,
                                               type_: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
pub type zend_object_count_elements_t =
    ::std::option::Option<unsafe extern "C" fn(object: *mut zval,
                                               count: *mut zend_long)
                              -> ::std::os::raw::c_int>;
pub type zend_object_get_closure_t =
    ::std::option::Option<unsafe extern "C" fn(obj: *mut zval,
                                               ce_ptr:
                                                   *mut *mut zend_class_entry,
                                               fptr_ptr:
                                                   *mut *mut _zend_function,
                                               obj_ptr: *mut *mut zend_object)
                              -> ::std::os::raw::c_int>;
pub type zend_object_get_gc_t =
    ::std::option::Option<unsafe extern "C" fn(object: *mut zval,
                                               table: *mut *mut zval,
                                               n: *mut ::std::os::raw::c_int)
                              -> *mut HashTable>;
pub type zend_object_do_operation_t =
    ::std::option::Option<unsafe extern "C" fn(opcode: zend_uchar,
                                               result: *mut zval,
                                               op1: *mut zval, op2: *mut zval)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "std_object_handlers"]
    pub static mut std_object_handlers: zend_object_handlers;
}
extern "C" {
    pub fn zend_std_get_static_method(ce: *mut zend_class_entry,
                                      function_name_strval: *mut zend_string,
                                      key: *const zval)
     -> *mut _zend_function;
}
extern "C" {
    pub fn zend_std_get_static_property(ce: *mut zend_class_entry,
                                        property_name: *mut zend_string,
                                        silent: zend_bool) -> *mut zval;
}
extern "C" {
    pub fn zend_std_unset_static_property(ce: *mut zend_class_entry,
                                          property_name: *mut zend_string)
     -> zend_bool;
}
extern "C" {
    pub fn zend_std_get_constructor(object: *mut zend_object)
     -> *mut _zend_function;
}
extern "C" {
    pub fn zend_get_property_info(ce: *mut zend_class_entry,
                                  member: *mut zend_string,
                                  silent: ::std::os::raw::c_int)
     -> *mut _zend_property_info;
}
extern "C" {
    pub fn zend_std_get_properties(object: *mut zval) -> *mut HashTable;
}
extern "C" {
    pub fn zend_std_get_debug_info(object: *mut zval,
                                   is_temp: *mut ::std::os::raw::c_int)
     -> *mut HashTable;
}
extern "C" {
    pub fn zend_std_cast_object_tostring(readobj: *mut zval,
                                         writeobj: *mut zval,
                                         type_: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_std_write_property(object: *mut zval, member: *mut zval,
                                   value: *mut zval,
                                   cache_slot:
                                       *mut *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn rebuild_object_properties(zobj: *mut zend_object);
}
extern "C" {
    pub fn zend_check_private(fbc: *mut _zend_function,
                              ce: *mut zend_class_entry,
                              function_name: *mut zend_string)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_check_protected(ce: *mut zend_class_entry,
                                scope: *mut zend_class_entry)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_check_property_access(zobj: *mut zend_object,
                                      prop_info_name: *mut zend_string)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_get_call_trampoline_func(ce: *mut zend_class_entry,
                                         method_name: *mut zend_string,
                                         is_static: ::std::os::raw::c_int)
     -> *mut zend_function;
}
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "program_invocation_name"]
    pub static mut program_invocation_name: *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "program_invocation_short_name"]
    pub static mut program_invocation_short_name: *mut ::std::os::raw::c_char;
}
pub type error_t = ::std::os::raw::c_int;
extern "C" {
    pub fn zend_freedtoa(s: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn zend_dtoa(_d: f64, mode: ::std::os::raw::c_int,
                     ndigits: ::std::os::raw::c_int,
                     decpt: *mut ::std::os::raw::c_int,
                     sign: *mut ::std::os::raw::c_int,
                     rve: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn zend_strtod(s00: *const ::std::os::raw::c_char,
                       se: *mut *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn zend_hex_strtod(str: *const ::std::os::raw::c_char,
                           endptr: *mut *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn zend_oct_strtod(str: *const ::std::os::raw::c_char,
                           endptr: *mut *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn zend_bin_strtod(str: *const ::std::os::raw::c_char,
                           endptr: *mut *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn zend_startup_strtod() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_shutdown_strtod() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn add_function(result: *mut zval, op1: *mut zval, op2: *mut zval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sub_function(result: *mut zval, op1: *mut zval, op2: *mut zval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mul_function(result: *mut zval, op1: *mut zval, op2: *mut zval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pow_function(result: *mut zval, op1: *mut zval, op2: *mut zval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn div_function(result: *mut zval, op1: *mut zval, op2: *mut zval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mod_function(result: *mut zval, op1: *mut zval, op2: *mut zval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn boolean_xor_function(result: *mut zval, op1: *mut zval,
                                op2: *mut zval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn boolean_not_function(result: *mut zval, op1: *mut zval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitwise_not_function(result: *mut zval, op1: *mut zval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitwise_or_function(result: *mut zval, op1: *mut zval,
                               op2: *mut zval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitwise_and_function(result: *mut zval, op1: *mut zval,
                                op2: *mut zval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bitwise_xor_function(result: *mut zval, op1: *mut zval,
                                op2: *mut zval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shift_left_function(result: *mut zval, op1: *mut zval,
                               op2: *mut zval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shift_right_function(result: *mut zval, op1: *mut zval,
                                op2: *mut zval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn concat_function(result: *mut zval, op1: *mut zval, op2: *mut zval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_is_identical(op1: *mut zval, op2: *mut zval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_equal_function(result: *mut zval, op1: *mut zval,
                             op2: *mut zval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_identical_function(result: *mut zval, op1: *mut zval,
                                 op2: *mut zval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_not_identical_function(result: *mut zval, op1: *mut zval,
                                     op2: *mut zval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_not_equal_function(result: *mut zval, op1: *mut zval,
                                 op2: *mut zval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_smaller_function(result: *mut zval, op1: *mut zval,
                               op2: *mut zval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_smaller_or_equal_function(result: *mut zval, op1: *mut zval,
                                        op2: *mut zval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn instanceof_function_ex(instance_ce: *const zend_class_entry,
                                  ce: *const zend_class_entry,
                                  interfaces_only: zend_bool) -> zend_bool;
}
extern "C" {
    pub fn instanceof_function(instance_ce: *const zend_class_entry,
                               ce: *const zend_class_entry) -> zend_bool;
}
extern "C" {
    /// Checks whether the string "str" with length "length" is numeric. The value
/// of allow_errors determines whether it's required to be entirely numeric, or
/// just its prefix. Leading whitespace is allowed.
///
/// The function returns 0 if the string did not contain a valid number; IS_LONG
/// if it contained a number that fits within the range of a long; or IS_DOUBLE
/// if the number was out of long range or contained a decimal point/exponent.
/// The number's value is returned into the respective pointer, *lval or *dval,
/// if that pointer is not NULL.
///
/// This variant also gives information if a string that represents an integer
/// could not be represented as such due to overflow. It writes 1 to oflow_info
/// if the integer is larger than ZEND_LONG_MAX and -1 if it's smaller than ZEND_LONG_MIN.
    pub fn _is_numeric_string_ex(str: *const ::std::os::raw::c_char,
                                 length: usize, lval: *mut zend_long,
                                 dval: *mut f64,
                                 allow_errors: ::std::os::raw::c_int,
                                 oflow_info: *mut ::std::os::raw::c_int)
     -> zend_uchar;
}
extern "C" {
    pub fn zend_memnstr_ex(haystack: *const ::std::os::raw::c_char,
                           needle: *const ::std::os::raw::c_char,
                           needle_len: usize,
                           end: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn zend_memnrstr_ex(haystack: *const ::std::os::raw::c_char,
                            needle: *const ::std::os::raw::c_char,
                            needle_len: usize,
                            end: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn zend_dval_to_lval_slow(d: f64) -> zend_long;
}
extern "C" {
    pub fn is_numeric_str_function(str: *const zend_string,
                                   lval: *mut zend_long, dval: *mut f64)
     -> zend_uchar;
}
extern "C" {
    pub fn increment_function(op1: *mut zval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decrement_function(op2: *mut zval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn convert_scalar_to_number(op: *mut zval);
}
extern "C" {
    pub fn _convert_to_cstring(op: *mut zval);
}
extern "C" {
    pub fn _convert_to_string(op: *mut zval);
}
extern "C" {
    pub fn convert_to_long(op: *mut zval);
}
extern "C" {
    pub fn convert_to_double(op: *mut zval);
}
extern "C" {
    pub fn convert_to_long_base(op: *mut zval, base: ::std::os::raw::c_int);
}
extern "C" {
    pub fn convert_to_null(op: *mut zval);
}
extern "C" {
    pub fn convert_to_boolean(op: *mut zval);
}
extern "C" {
    pub fn convert_to_array(op: *mut zval);
}
extern "C" {
    pub fn convert_to_object(op: *mut zval);
}
extern "C" {
    pub fn multi_convert_to_long_ex(argc: ::std::os::raw::c_int, ...);
}
extern "C" {
    pub fn multi_convert_to_double_ex(argc: ::std::os::raw::c_int, ...);
}
extern "C" {
    pub fn multi_convert_to_string_ex(argc: ::std::os::raw::c_int, ...);
}
extern "C" {
    pub fn _zval_get_long_func(op: *mut zval) -> zend_long;
}
extern "C" {
    pub fn _zval_get_double_func(op: *mut zval) -> f64;
}
extern "C" {
    pub fn _zval_get_string_func(op: *mut zval) -> *mut zend_string;
}
extern "C" {
    pub fn zend_is_true(op: *mut zval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_object_is_true(op: *mut zval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn compare_function(result: *mut zval, op1: *mut zval, op2: *mut zval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn numeric_compare_function(op1: *mut zval, op2: *mut zval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn string_compare_function_ex(op1: *mut zval, op2: *mut zval,
                                      case_insensitive: zend_bool)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn string_compare_function(op1: *mut zval, op2: *mut zval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn string_case_compare_function(op1: *mut zval, op2: *mut zval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn string_locale_compare_function(op1: *mut zval, op2: *mut zval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_str_tolower(str: *mut ::std::os::raw::c_char, length: usize);
}
extern "C" {
    pub fn zend_str_tolower_copy(dest: *mut ::std::os::raw::c_char,
                                 source: *const ::std::os::raw::c_char,
                                 length: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn zend_str_tolower_dup(source: *const ::std::os::raw::c_char,
                                length: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn zend_str_tolower_dup_ex(source: *const ::std::os::raw::c_char,
                                   length: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn zend_string_tolower(str: *mut zend_string) -> *mut zend_string;
}
extern "C" {
    pub fn zend_binary_zval_strcmp(s1: *mut zval, s2: *mut zval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_binary_zval_strncmp(s1: *mut zval, s2: *mut zval,
                                    s3: *mut zval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_binary_zval_strcasecmp(s1: *mut zval, s2: *mut zval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_binary_zval_strncasecmp(s1: *mut zval, s2: *mut zval,
                                        s3: *mut zval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_binary_strcmp(s1: *const ::std::os::raw::c_char, len1: usize,
                              s2: *const ::std::os::raw::c_char, len2: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_binary_strncmp(s1: *const ::std::os::raw::c_char, len1: usize,
                               s2: *const ::std::os::raw::c_char, len2: usize,
                               length: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_binary_strcasecmp(s1: *const ::std::os::raw::c_char,
                                  len1: usize,
                                  s2: *const ::std::os::raw::c_char,
                                  len2: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_binary_strncasecmp(s1: *const ::std::os::raw::c_char,
                                   len1: usize,
                                   s2: *const ::std::os::raw::c_char,
                                   len2: usize, length: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_binary_strcasecmp_l(s1: *const ::std::os::raw::c_char,
                                    len1: usize,
                                    s2: *const ::std::os::raw::c_char,
                                    len2: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_binary_strncasecmp_l(s1: *const ::std::os::raw::c_char,
                                     len1: usize,
                                     s2: *const ::std::os::raw::c_char,
                                     len2: usize, length: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zendi_smart_strcmp(s1: *mut zend_string, s2: *mut zend_string)
     -> zend_long;
}
extern "C" {
    pub fn zend_compare_symbol_tables(ht1: *mut HashTable,
                                      ht2: *mut HashTable)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_compare_arrays(a1: *mut zval, a2: *mut zval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_compare_objects(o1: *mut zval, o2: *mut zval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_atoi(str: *const ::std::os::raw::c_char,
                     str_len: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_atol(str: *const ::std::os::raw::c_char,
                     str_len: ::std::os::raw::c_int) -> zend_long;
}
extern "C" {
    pub fn zend_locale_sprintf_double(op: *mut zval);
}
extern "C" {
    pub fn zend_long_to_str(num: zend_long) -> *mut zend_string;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _zend_ast_kind {
    ZEND_AST_ZVAL = 64,
    ZEND_AST_ZNODE = 65,
    ZEND_AST_FUNC_DECL = 66,
    ZEND_AST_CLOSURE = 67,
    ZEND_AST_METHOD = 68,
    ZEND_AST_CLASS = 69,
    ZEND_AST_ARG_LIST = 128,
    ZEND_AST_LIST = 129,
    ZEND_AST_ARRAY = 130,
    ZEND_AST_ENCAPS_LIST = 131,
    ZEND_AST_EXPR_LIST = 132,
    ZEND_AST_STMT_LIST = 133,
    ZEND_AST_IF = 134,
    ZEND_AST_SWITCH_LIST = 135,
    ZEND_AST_CATCH_LIST = 136,
    ZEND_AST_PARAM_LIST = 137,
    ZEND_AST_CLOSURE_USES = 138,
    ZEND_AST_PROP_DECL = 139,
    ZEND_AST_CONST_DECL = 140,
    ZEND_AST_CLASS_CONST_DECL = 141,
    ZEND_AST_NAME_LIST = 142,
    ZEND_AST_TRAIT_ADAPTATIONS = 143,
    ZEND_AST_USE = 144,
    ZEND_AST_MAGIC_CONST = 0,
    ZEND_AST_TYPE = 1,
    ZEND_AST_VAR = 256,
    ZEND_AST_CONST = 257,
    ZEND_AST_UNPACK = 258,
    ZEND_AST_UNARY_PLUS = 259,
    ZEND_AST_UNARY_MINUS = 260,
    ZEND_AST_CAST = 261,
    ZEND_AST_EMPTY = 262,
    ZEND_AST_ISSET = 263,
    ZEND_AST_SILENCE = 264,
    ZEND_AST_SHELL_EXEC = 265,
    ZEND_AST_CLONE = 266,
    ZEND_AST_EXIT = 267,
    ZEND_AST_PRINT = 268,
    ZEND_AST_INCLUDE_OR_EVAL = 269,
    ZEND_AST_UNARY_OP = 270,
    ZEND_AST_PRE_INC = 271,
    ZEND_AST_PRE_DEC = 272,
    ZEND_AST_POST_INC = 273,
    ZEND_AST_POST_DEC = 274,
    ZEND_AST_YIELD_FROM = 275,
    ZEND_AST_GLOBAL = 276,
    ZEND_AST_UNSET = 277,
    ZEND_AST_RETURN = 278,
    ZEND_AST_LABEL = 279,
    ZEND_AST_REF = 280,
    ZEND_AST_HALT_COMPILER = 281,
    ZEND_AST_ECHO = 282,
    ZEND_AST_THROW = 283,
    ZEND_AST_GOTO = 284,
    ZEND_AST_BREAK = 285,
    ZEND_AST_CONTINUE = 286,
    ZEND_AST_DIM = 512,
    ZEND_AST_PROP = 513,
    ZEND_AST_STATIC_PROP = 514,
    ZEND_AST_CALL = 515,
    ZEND_AST_CLASS_CONST = 516,
    ZEND_AST_ASSIGN = 517,
    ZEND_AST_ASSIGN_REF = 518,
    ZEND_AST_ASSIGN_OP = 519,
    ZEND_AST_BINARY_OP = 520,
    ZEND_AST_GREATER = 521,
    ZEND_AST_GREATER_EQUAL = 522,
    ZEND_AST_AND = 523,
    ZEND_AST_OR = 524,
    ZEND_AST_ARRAY_ELEM = 525,
    ZEND_AST_NEW = 526,
    ZEND_AST_INSTANCEOF = 527,
    ZEND_AST_YIELD = 528,
    ZEND_AST_COALESCE = 529,
    ZEND_AST_STATIC = 530,
    ZEND_AST_WHILE = 531,
    ZEND_AST_DO_WHILE = 532,
    ZEND_AST_IF_ELEM = 533,
    ZEND_AST_SWITCH = 534,
    ZEND_AST_SWITCH_CASE = 535,
    ZEND_AST_DECLARE = 536,
    ZEND_AST_CONST_ELEM = 537,
    ZEND_AST_USE_TRAIT = 538,
    ZEND_AST_TRAIT_PRECEDENCE = 539,
    ZEND_AST_METHOD_REFERENCE = 540,
    ZEND_AST_NAMESPACE = 541,
    ZEND_AST_USE_ELEM = 542,
    ZEND_AST_TRAIT_ALIAS = 543,
    ZEND_AST_GROUP_USE = 544,
    ZEND_AST_METHOD_CALL = 768,
    ZEND_AST_STATIC_CALL = 769,
    ZEND_AST_CONDITIONAL = 770,
    ZEND_AST_TRY = 771,
    ZEND_AST_CATCH = 772,
    ZEND_AST_PARAM = 773,
    ZEND_AST_PROP_ELEM = 774,
    ZEND_AST_FOR = 1024,
    ZEND_AST_FOREACH = 1025,
}
pub type zend_ast_kind = u16;
pub type zend_ast_attr = u16;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _zend_ast_list {
    pub kind: zend_ast_kind,
    pub attr: zend_ast_attr,
    pub lineno: u32,
    pub children: u32,
    pub child: [*mut zend_ast; 1usize],
}
#[test]
fn bindgen_test_layout__zend_ast_list() {
    assert_eq!(::std::mem::size_of::<_zend_ast_list>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _zend_ast_list ) ));
    assert_eq! (::std::mem::align_of::<_zend_ast_list>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _zend_ast_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_ast_list ) ) . kind as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_ast_list ) , "::"
                , stringify ! ( kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_ast_list ) ) . attr as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_ast_list ) , "::"
                , stringify ! ( attr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_ast_list ) ) . lineno as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_ast_list ) , "::"
                , stringify ! ( lineno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_ast_list ) ) . children as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_ast_list ) , "::"
                , stringify ! ( children ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_ast_list ) ) . child as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_ast_list ) , "::"
                , stringify ! ( child ) ));
}
impl Clone for _zend_ast_list {
    fn clone(&self) -> Self { *self }
}
impl Default for _zend_ast_list {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type zend_ast_list = _zend_ast_list;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _zend_ast_zval {
    pub kind: zend_ast_kind,
    pub attr: zend_ast_attr,
    pub val: zval,
}
#[test]
fn bindgen_test_layout__zend_ast_zval() {
    assert_eq!(::std::mem::size_of::<_zend_ast_zval>() , 24usize , concat ! (
               "Size of: " , stringify ! ( _zend_ast_zval ) ));
    assert_eq! (::std::mem::align_of::<_zend_ast_zval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _zend_ast_zval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_ast_zval ) ) . kind as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_ast_zval ) , "::"
                , stringify ! ( kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_ast_zval ) ) . attr as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_ast_zval ) , "::"
                , stringify ! ( attr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_ast_zval ) ) . val as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_ast_zval ) , "::"
                , stringify ! ( val ) ));
}
impl Clone for _zend_ast_zval {
    fn clone(&self) -> Self { *self }
}
pub type zend_ast_zval = _zend_ast_zval;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _zend_ast_decl {
    pub kind: zend_ast_kind,
    pub attr: zend_ast_attr,
    pub start_lineno: u32,
    pub end_lineno: u32,
    pub flags: u32,
    pub lex_pos: *mut ::std::os::raw::c_uchar,
    pub doc_comment: *mut zend_string,
    pub name: *mut zend_string,
    pub child: [*mut zend_ast; 4usize],
}
#[test]
fn bindgen_test_layout__zend_ast_decl() {
    assert_eq!(::std::mem::size_of::<_zend_ast_decl>() , 72usize , concat ! (
               "Size of: " , stringify ! ( _zend_ast_decl ) ));
    assert_eq! (::std::mem::align_of::<_zend_ast_decl>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _zend_ast_decl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_ast_decl ) ) . kind as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_ast_decl ) , "::"
                , stringify ! ( kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_ast_decl ) ) . attr as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_ast_decl ) , "::"
                , stringify ! ( attr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_ast_decl ) ) . start_lineno as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_ast_decl ) , "::"
                , stringify ! ( start_lineno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_ast_decl ) ) . end_lineno as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_ast_decl ) , "::"
                , stringify ! ( end_lineno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_ast_decl ) ) . flags as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_ast_decl ) , "::"
                , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_ast_decl ) ) . lex_pos as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_ast_decl ) , "::"
                , stringify ! ( lex_pos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_ast_decl ) ) . doc_comment as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_ast_decl ) , "::"
                , stringify ! ( doc_comment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_ast_decl ) ) . name as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_ast_decl ) , "::"
                , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _zend_ast_decl ) ) . child as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( _zend_ast_decl ) , "::"
                , stringify ! ( child ) ));
}
impl Clone for _zend_ast_decl {
    fn clone(&self) -> Self { *self }
}
impl Default for _zend_ast_decl {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type zend_ast_decl = _zend_ast_decl;
pub type zend_ast_process_t =
    ::std::option::Option<unsafe extern "C" fn(ast: *mut zend_ast)>;
extern "C" {
    #[link_name = "zend_ast_process"]
    pub static mut zend_ast_process: zend_ast_process_t;
}
extern "C" {
    pub fn zend_ast_create_zval_with_lineno(zv: *mut zval,
                                            attr: zend_ast_attr, lineno: u32)
     -> *mut zend_ast;
}
extern "C" {
    pub fn zend_ast_create_zval_ex(zv: *mut zval, attr: zend_ast_attr)
     -> *mut zend_ast;
}
extern "C" {
    pub fn zend_ast_create_ex(kind: zend_ast_kind, attr: zend_ast_attr, ...)
     -> *mut zend_ast;
}
extern "C" {
    pub fn zend_ast_create(kind: zend_ast_kind, ...) -> *mut zend_ast;
}
extern "C" {
    pub fn zend_ast_create_decl(kind: zend_ast_kind, flags: u32,
                                start_lineno: u32,
                                doc_comment: *mut zend_string,
                                name: *mut zend_string, child0: *mut zend_ast,
                                child1: *mut zend_ast, child2: *mut zend_ast,
                                child3: *mut zend_ast) -> *mut zend_ast;
}
extern "C" {
    pub fn zend_ast_create_list(init_children: u32, kind: zend_ast_kind, ...)
     -> *mut zend_ast;
}
extern "C" {
    pub fn zend_ast_list_add(list: *mut zend_ast, op: *mut zend_ast)
     -> *mut zend_ast;
}
extern "C" {
    pub fn zend_ast_evaluate(result: *mut zval, ast: *mut zend_ast,
                             scope: *mut zend_class_entry)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn zend_ast_export(prefix: *const ::std::os::raw::c_char,
                           ast: *mut zend_ast,
                           suffix: *const ::std::os::raw::c_char)
     -> *mut zend_string;
}
extern "C" {
    pub fn zend_ast_copy(ast: *mut zend_ast) -> *mut zend_ast;
}
extern "C" {
    pub fn zend_ast_destroy(ast: *mut zend_ast);
}
extern "C" {
    pub fn zend_ast_destroy_and_free(ast: *mut zend_ast);
}
pub type zend_ast_apply_func =
    ::std::option::Option<unsafe extern "C" fn(ast_ptr: *mut *mut zend_ast)>;
extern "C" {
    pub fn zend_ast_apply(ast: *mut zend_ast, fn_: zend_ast_apply_func);
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __locale_data {
    pub _address: u8,
}
impl Clone for __locale_data {
    fn clone(&self) -> Self { *self }
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
impl Default for __va_list_tag {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _zend_function_entry {
    pub _address: u8,
}
impl Clone for _zend_function_entry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _zend_module_entry {
    pub _address: u8,
}
impl Clone for _zend_module_entry {
    fn clone(&self) -> Self { *self }
}
